"""GraphQL types for User.

⚠️ AUTO-GENERATED BY PRISM - DO NOT EDIT
"""

import datetime
from typing import TYPE_CHECKING, Annotated, Any

import strawberry
from strawberry.types import Info

if TYPE_CHECKING:
    from .api_key import APIKeyType
    from .subdomain import SubdomainType


@strawberry.type(description="User account for madewithpris.me")
class UserType:
    """GraphQL type for User."""

    id: int
    email: str = strawberry.field(description="User email address")
    passwordHash: str | None = strawberry.field(description="Hashed password (bcrypt)")
    emailVerified: bool = strawberry.field(description="Whether email has been verified")
    emailVerificationToken: str | None = strawberry.field(
        description="Token for email verification"
    )
    mfaEnabled: bool = strawberry.field(description="Whether MFA is enabled")
    mfaSecret: str | None = strawberry.field(description="TOTP MFA secret")
    subdomainLimit: int = strawberry.field(description="Maximum number of subdomains allowed")
    isAdmin: bool = strawberry.field(description="Whether user has admin privileges")
    passwordResetToken: str | None = strawberry.field(description="Token for password reset")
    passwordResetTokenExpiresAt: datetime.datetime | None = strawberry.field(
        description="When password reset token expires"
    )
    emailVerificationTokenExpiresAt: datetime.datetime | None = strawberry.field(
        description="When email verification token expires"
    )
    failedLoginAttempts: int = strawberry.field(
        description="Number of consecutive failed login attempts"
    )
    lockedUntil: datetime.datetime | None = strawberry.field(
        description="Account locked until this time after too many failed logins"
    )
    githubId: str | None = strawberry.field(description="GitHub user ID for OAuth")
    username: str | None = strawberry.field(description="Username (optional, email is primary)")
    roles: strawberry.scalars.JSON = strawberry.field(description="User roles for authorization")
    isActive: bool = strawberry.field(description="Whether user account is active")
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    deletedAt: datetime.datetime | None = None

    # Private fields for relationship lazy loading
    _db_api_keys: strawberry.Private[Any] = None
    _db_subdomains: strawberry.Private[Any] = None

    # Relationship resolvers

    @strawberry.field
    async def apiKeys(
        self, info: Info
    ) -> list[Annotated["APIKeyType", strawberry.lazy(".api_key")]]:
        """Fetch related APIKey entities."""
        from .api_key import api_key_from_model

        if self._db_api_keys is None:
            return []
        return [api_key_from_model(item) for item in self._db_api_keys]

    @strawberry.field
    async def subdomains(
        self, info: Info
    ) -> list[Annotated["SubdomainType", strawberry.lazy(".subdomain")]]:
        """Fetch related Subdomain entities."""
        from .subdomain import subdomain_from_model

        if self._db_subdomains is None:
            return []
        return [subdomain_from_model(item) for item in self._db_subdomains]


@strawberry.input(description="Input for creating a User")
class UserInput:
    """Input type for creating User."""

    email: str
    passwordHash: str | None = None
    emailVerified: bool = False
    emailVerificationToken: str | None = None
    mfaEnabled: bool = False
    mfaSecret: str | None = None
    subdomainLimit: int = 10
    isAdmin: bool = False
    passwordResetToken: str | None = None
    passwordResetTokenExpiresAt: datetime.datetime | None = None
    emailVerificationTokenExpiresAt: datetime.datetime | None = None
    failedLoginAttempts: int = 0
    lockedUntil: datetime.datetime | None = None
    githubId: str | None = None
    username: str | None = None
    roles: strawberry.scalars.JSON = strawberry.field(default_factory=lambda: ["user"])
    isActive: bool = True
    apiKeysIds: list[int] | None = None
    subdomainsIds: list[int] | None = None


@strawberry.input(description="Input for updating a User")
class UserUpdateInput:
    """Input type for updating User. All fields are optional."""

    email: str | None = None
    passwordHash: str | None = None
    emailVerified: bool | None = None
    emailVerificationToken: str | None = None
    mfaEnabled: bool | None = None
    mfaSecret: str | None = None
    subdomainLimit: int | None = None
    isAdmin: bool | None = None
    passwordResetToken: str | None = None
    passwordResetTokenExpiresAt: datetime.datetime | None = None
    emailVerificationTokenExpiresAt: datetime.datetime | None = None
    failedLoginAttempts: int | None = None
    lockedUntil: datetime.datetime | None = None
    githubId: str | None = None
    username: str | None = None
    roles: strawberry.scalars.JSON | None = None
    isActive: bool | None = None
    apiKeysIds: list[int] | None = None
    subdomainsIds: list[int] | None = None


def user_from_model(obj: Any) -> UserType:
    """Convert a SQLAlchemy model to GraphQL type."""
    return UserType(
        id=obj.id,
        email=obj.email,
        passwordHash=obj.password_hash,
        emailVerified=obj.email_verified,
        emailVerificationToken=obj.email_verification_token,
        mfaEnabled=obj.mfa_enabled,
        mfaSecret=obj.mfa_secret,
        subdomainLimit=obj.subdomain_limit,
        isAdmin=obj.is_admin,
        passwordResetToken=obj.password_reset_token,
        passwordResetTokenExpiresAt=obj.password_reset_token_expires_at,
        emailVerificationTokenExpiresAt=obj.email_verification_token_expires_at,
        failedLoginAttempts=obj.failed_login_attempts,
        lockedUntil=obj.locked_until,
        githubId=obj.github_id,
        username=obj.username,
        roles=obj.roles,
        isActive=obj.is_active,
        createdAt=obj.created_at,
        updatedAt=obj.updated_at,
        deletedAt=obj.deleted_at,
        _db_api_keys=obj.__dict__.get("api_keys"),
        _db_subdomains=obj.__dict__.get("subdomains"),
    )


__all__ = ["UserInput", "UserType", "UserUpdateInput", "user_from_model"]
