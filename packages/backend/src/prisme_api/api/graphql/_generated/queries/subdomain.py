"""GraphQL queries for Subdomain.

⚠️ AUTO-GENERATED BY PRISM - DO NOT EDIT
"""

from __future__ import annotations

from typing import Any

import strawberry
from strawberry.types import Info

from prisme_api.schemas.subdomain import SubdomainFilter
from prisme_api.services.subdomain import SubdomainService

from ..context import Context
from ..filters.subdomain import SubdomainWhereInput
from ..pagination import Connection, OffsetPaginationInput, paginate_results
from ..types.subdomain import SubdomainType, subdomain_from_model


@strawberry.type
class SubdomainQueries:
    """GraphQL queries for Subdomain."""

    @strawberry.field(description="Get a single Subdomain by ID")
    async def subdomain(
        self,
        info: Info[Context, None],
        id: int,
    ) -> SubdomainType | None:
        """Get a Subdomain by ID. Users can only access their own."""
        # Require authentication
        info.context.require_auth()

        service = SubdomainService(info.context.db)
        result = await service.get(id)
        if result is None:
            return None

        # Check ownership for non-admin users
        if not info.context.is_owner_or_admin(result.owner_id):
            raise PermissionError("Access denied")

        return subdomain_from_model(result)

    @strawberry.field(description="List subdomains with filtering and pagination")
    async def subdomains(
        self,
        info: Info[Context, None],
        where: SubdomainWhereInput | None = None,
        pagination: OffsetPaginationInput | None = None,
    ) -> Connection[SubdomainType]:
        """List subdomains. Users see only their own, admins see all."""
        # Require authentication
        user = info.context.require_auth()

        service = SubdomainService(info.context.db)

        page = pagination.page if pagination else 1
        page_size = pagination.page_size if pagination else 20
        skip = (page - 1) * page_size

        # Convert GraphQL where input to service filter
        filters = _convert_where_to_filter(where) if where else SubdomainFilter()

        # Apply owner filter for non-admin users
        if "admin" not in (user.roles or []):
            filters = SubdomainFilter(**filters.model_dump(), owner_id=user.id)

        items = await service.list(skip=skip, limit=page_size, filters=filters)
        total = await service.count_filtered(filters=filters)

        typed_items = [subdomain_from_model(item) for item in items]
        return paginate_results(typed_items, total, page, page_size)


def _convert_where_to_filter(where: SubdomainWhereInput) -> SubdomainFilter:
    """Convert GraphQL where input to Pydantic filter schema."""
    filter_dict: dict[str, Any] = {}

    # Handle ID filter
    if where.id is not None:
        _apply_int_filter(filter_dict, "id", where.id)

    return SubdomainFilter(**filter_dict)


def _apply_int_filter(filter_dict: dict[str, Any], field_name: str, filter_input: Any) -> None:
    """Apply an integer filter to the filter dictionary."""
    if filter_input.eq is not None:
        filter_dict[field_name] = filter_input.eq
    if filter_input.ne is not None:
        filter_dict[f"{field_name}_ne"] = filter_input.ne
    if filter_input.gt is not None:
        filter_dict[f"{field_name}_gt"] = filter_input.gt
    if filter_input.gte is not None:
        filter_dict[f"{field_name}_gte"] = filter_input.gte
    if filter_input.lt is not None:
        filter_dict[f"{field_name}_lt"] = filter_input.lt
    if filter_input.lte is not None:
        filter_dict[f"{field_name}_lte"] = filter_input.lte
    if filter_input.in_ is not None:
        filter_dict[f"{field_name}_in"] = filter_input.in_


__all__ = ["SubdomainQueries"]
