"""GraphQL queries for User.

⚠️ AUTO-GENERATED BY PRISM - DO NOT EDIT
"""

from typing import Any

import strawberry
from strawberry.types import Info

from prisme_api.schemas.user import UserFilter
from prisme_api.services.user import UserService

from ..context import Context
from ..filters.user import UserWhereInput
from ..pagination import Connection, OffsetPaginationInput, paginate_results
from ..types.user import UserType, user_from_model


@strawberry.type
class UserQueries:
    """GraphQL queries for User."""

    @strawberry.field(description="Get a single User by ID")
    async def user(
        self,
        info: Info[Context, None],
        id: int,
    ) -> UserType | None:
        """Get a User by ID."""
        service = UserService(info.context.db)
        result = await service.get(id)
        if result is None:
            return None
        return user_from_model(result)

    @strawberry.field(description="List users with filtering and pagination")
    async def users(
        self,
        info: Info[Context, None],
        where: UserWhereInput | None = None,
        pagination: OffsetPaginationInput | None = None,
    ) -> Connection[UserType]:
        """List users."""
        service = UserService(info.context.db)

        page = pagination.page if pagination else 1
        page_size = pagination.page_size if pagination else 20
        skip = (page - 1) * page_size

        # Convert GraphQL where input to service filter
        filters = _convert_where_to_filter(where) if where else None

        items = await service.list(skip=skip, limit=page_size, filters=filters)
        total = await service.count_filtered(filters=filters)

        typed_items = [user_from_model(item) for item in items]
        return paginate_results(typed_items, total, page, page_size)


def _convert_where_to_filter(where: UserWhereInput) -> UserFilter:
    """Convert GraphQL where input to Pydantic filter schema."""
    filter_dict: dict[str, Any] = {}

    # Handle ID filter
    if where.id is not None:
        _apply_int_filter(filter_dict, "id", where.id)

    # Handle api_keys relationship filter
    if where.apiKeys is not None:
        api_keys_filter = where.apiKeys
        if api_keys_filter.some is not None and api_keys_filter.some.id is not None:
            if api_keys_filter.some.id.eq is not None:
                filter_dict["api_keys_id"] = api_keys_filter.some.id.eq
            elif api_keys_filter.some.id.in_ is not None:
                filter_dict["api_keys_ids"] = api_keys_filter.some.id.in_

    # Handle subdomains relationship filter
    if where.subdomains is not None:
        subdomains_filter = where.subdomains
        if subdomains_filter.some is not None and subdomains_filter.some.id is not None:
            if subdomains_filter.some.id.eq is not None:
                filter_dict["subdomains_id"] = subdomains_filter.some.id.eq
            elif subdomains_filter.some.id.in_ is not None:
                filter_dict["subdomains_ids"] = subdomains_filter.some.id.in_

    return UserFilter(**filter_dict)


def _apply_int_filter(filter_dict: dict[str, Any], field_name: str, filter_input: Any) -> None:
    """Apply an integer filter to the filter dictionary."""
    if filter_input.eq is not None:
        filter_dict[field_name] = filter_input.eq
    if filter_input.ne is not None:
        filter_dict[f"{field_name}_ne"] = filter_input.ne
    if filter_input.gt is not None:
        filter_dict[f"{field_name}_gt"] = filter_input.gt
    if filter_input.gte is not None:
        filter_dict[f"{field_name}_gte"] = filter_input.gte
    if filter_input.lt is not None:
        filter_dict[f"{field_name}_lt"] = filter_input.lt
    if filter_input.lte is not None:
        filter_dict[f"{field_name}_lte"] = filter_input.lte
    if filter_input.in_ is not None:
        filter_dict[f"{field_name}_in"] = filter_input.in_


__all__ = ["UserQueries"]
