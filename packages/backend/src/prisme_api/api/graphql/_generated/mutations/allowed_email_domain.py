"""GraphQL mutations for AllowedEmailDomain.

⚠️ AUTO-GENERATED BY PRISM - DO NOT EDIT
"""

import re

import strawberry
from strawberry.types import Info

from prisme_api.schemas.allowed_email_domain import (
    AllowedEmailDomainCreate,
    AllowedEmailDomainUpdate,
)
from prisme_api.services.allowed_email_domain import AllowedEmailDomainService

from ..context import Context
from ..types.allowed_email_domain import (
    AllowedEmailDomainInput,
    AllowedEmailDomainType,
    AllowedEmailDomainUpdateInput,
    allowed_email_domain_from_model,
)


def _camel_to_snake(name: str) -> str:
    """Convert camelCase to snake_case."""
    return re.sub(r"(?<!^)(?=[A-Z])", "_", name).lower()


def _convert_keys_to_snake(data: dict) -> dict:
    """Convert all dictionary keys from camelCase to snake_case."""
    return {_camel_to_snake(k): v for k, v in data.items()}


@strawberry.type
class AllowedEmailDomainMutations:
    """GraphQL mutations for AllowedEmailDomain."""

    @strawberry.mutation(description="Create a new AllowedEmailDomain")
    async def createAllowedEmailDomain(
        self,
        info: Info[Context, None],
        input: AllowedEmailDomainInput,
    ) -> AllowedEmailDomainType:
        """Create a new AllowedEmailDomain."""
        service = AllowedEmailDomainService(info.context.db)

        # Convert GraphQL input to Pydantic schema (camelCase -> snake_case)
        data = AllowedEmailDomainCreate(**_convert_keys_to_snake(strawberry.asdict(input)))
        result = await service.create(data=data)

        return allowed_email_domain_from_model(result)

    @strawberry.mutation(description="Update an existing AllowedEmailDomain")
    async def updateAllowedEmailDomain(
        self,
        info: Info[Context, None],
        id: int,
        input: AllowedEmailDomainUpdateInput,
    ) -> AllowedEmailDomainType | None:
        """Update a AllowedEmailDomain."""
        service = AllowedEmailDomainService(info.context.db)

        # Convert GraphQL input to Pydantic schema, excluding None values (camelCase -> snake_case)
        input_dict = {
            _camel_to_snake(k): v for k, v in strawberry.asdict(input).items() if v is not None
        }
        data = AllowedEmailDomainUpdate(**input_dict)
        result = await service.update(id=id, data=data)

        if result is None:
            return None
        return allowed_email_domain_from_model(result)

    @strawberry.mutation(description="Delete a AllowedEmailDomain")
    async def deleteAllowedEmailDomain(
        self,
        info: Info[Context, None],
        id: int,
    ) -> bool:
        """Delete a AllowedEmailDomain."""
        service = AllowedEmailDomainService(info.context.db)
        return await service.delete(id=id)

    @strawberry.mutation(description="Create multiple allowed_email_domains")
    async def createAllowedEmailDomains(
        self,
        info: Info[Context, None],
        input: list[AllowedEmailDomainInput],
    ) -> list[AllowedEmailDomainType]:
        """Create multiple allowed_email_domains in a single request."""
        service = AllowedEmailDomainService(info.context.db)

        data = [
            AllowedEmailDomainCreate(**_convert_keys_to_snake(strawberry.asdict(item)))
            for item in input
        ]
        results = await service.create_many(data=data)

        return [allowed_email_domain_from_model(item) for item in results]

    @strawberry.mutation(description="Update multiple allowed_email_domains")
    async def updateAllowedEmailDomains(
        self,
        info: Info[Context, None],
        ids: list[int],
        input: AllowedEmailDomainUpdateInput,
    ) -> int:
        """Update multiple allowed_email_domains with the same data. Returns count updated."""
        service = AllowedEmailDomainService(info.context.db)

        input_dict = {
            _camel_to_snake(k): v for k, v in strawberry.asdict(input).items() if v is not None
        }
        data = AllowedEmailDomainUpdate(**input_dict)

        return await service.update_many(ids=ids, data=data)

    @strawberry.mutation(description="Delete multiple allowed_email_domains")
    async def deleteAllowedEmailDomains(
        self,
        info: Info[Context, None],
        ids: list[int],
    ) -> int:
        """Delete multiple allowed_email_domains. Returns count deleted."""
        service = AllowedEmailDomainService(info.context.db)
        return await service.delete_many(ids=ids)


__all__ = ["AllowedEmailDomainMutations"]
