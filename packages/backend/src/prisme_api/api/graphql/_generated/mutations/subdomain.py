"""GraphQL mutations for Subdomain.

⚠️ AUTO-GENERATED BY PRISM - DO NOT EDIT
"""

from __future__ import annotations

import re

import strawberry
from strawberry.types import Info

from prisme_api.schemas.subdomain import SubdomainCreate, SubdomainUpdate
from prisme_api.services.subdomain import SubdomainService

from ..context import Context
from ..types.subdomain import (
    SubdomainInput,
    SubdomainType,
    SubdomainUpdateInput,
    subdomain_from_model,
)


def _camel_to_snake(name: str) -> str:
    """Convert camelCase to snake_case."""
    return re.sub(r"(?<!^)(?=[A-Z])", "_", name).lower()


def _convert_keys_to_snake(data: dict) -> dict:
    """Convert all dictionary keys from camelCase to snake_case."""
    return {_camel_to_snake(k): v for k, v in data.items()}


@strawberry.type
class SubdomainMutations:
    """GraphQL mutations for Subdomain."""

    @strawberry.mutation(description="Create a new Subdomain")
    async def createSubdomain(
        self,
        info: Info[Context, None],
        input: SubdomainInput,
    ) -> SubdomainType:
        """Create a new Subdomain."""
        service = SubdomainService(info.context.db)

        # Convert GraphQL input to Pydantic schema (camelCase -> snake_case)
        data = SubdomainCreate(**_convert_keys_to_snake(strawberry.asdict(input)))
        result = await service.create(data=data)

        return subdomain_from_model(result)

    @strawberry.mutation(description="Update an existing Subdomain")
    async def updateSubdomain(
        self,
        info: Info[Context, None],
        id: int,
        input: SubdomainUpdateInput,
    ) -> SubdomainType | None:
        """Update a Subdomain."""
        service = SubdomainService(info.context.db)

        # Convert GraphQL input to Pydantic schema, excluding None values (camelCase -> snake_case)
        input_dict = {
            _camel_to_snake(k): v for k, v in strawberry.asdict(input).items() if v is not None
        }
        data = SubdomainUpdate(**input_dict)
        result = await service.update(id=id, data=data)

        if result is None:
            return None
        return subdomain_from_model(result)

    @strawberry.mutation(description="Delete a Subdomain")
    async def deleteSubdomain(
        self,
        info: Info[Context, None],
        id: int,
    ) -> bool:
        """Delete a Subdomain."""
        service = SubdomainService(info.context.db)
        return await service.delete(id=id)

    @strawberry.mutation(description="Create multiple subdomains")
    async def createSubdomains(
        self,
        info: Info[Context, None],
        input: list[SubdomainInput],
    ) -> list[SubdomainType]:
        """Create multiple subdomains in a single request."""
        service = SubdomainService(info.context.db)

        data = [
            SubdomainCreate(**_convert_keys_to_snake(strawberry.asdict(item))) for item in input
        ]
        results = await service.create_many(data=data)

        return [subdomain_from_model(item) for item in results]

    @strawberry.mutation(description="Update multiple subdomains")
    async def updateSubdomains(
        self,
        info: Info[Context, None],
        ids: list[int],
        input: SubdomainUpdateInput,
    ) -> int:
        """Update multiple subdomains with the same data. Returns count updated."""
        service = SubdomainService(info.context.db)

        input_dict = {
            _camel_to_snake(k): v for k, v in strawberry.asdict(input).items() if v is not None
        }
        data = SubdomainUpdate(**input_dict)

        return await service.update_many(ids=ids, data=data)

    @strawberry.mutation(description="Delete multiple subdomains")
    async def deleteSubdomains(
        self,
        info: Info[Context, None],
        ids: list[int],
    ) -> int:
        """Delete multiple subdomains. Returns count deleted."""
        service = SubdomainService(info.context.db)
        return await service.delete_many(ids=ids)


__all__ = ["SubdomainMutations"]
