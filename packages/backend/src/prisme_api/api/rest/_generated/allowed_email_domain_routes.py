"""REST API routes for AllowedEmailDomain.

⚠️ AUTO-GENERATED BY PRISM - DO NOT EDIT
Extend this router in api/rest/allowed_email_domain.py
"""

from __future__ import annotations

from typing import Annotated

from fastapi import APIRouter, HTTPException, Query, status

from prisme_api.schemas.allowed_email_domain import (
    AllowedEmailDomainCreate,
    AllowedEmailDomainRead,
    AllowedEmailDomainUpdate,
)
from prisme_api.schemas.base import PaginatedResponse
from prisme_api.services.allowed_email_domain import AllowedEmailDomainService

from .deps import DbSession, Pagination, Sorting

router = APIRouter(prefix="/allowed-email-domains", tags=["allowed-email-domains"])


@router.get(
    "",
    response_model=PaginatedResponse[AllowedEmailDomainRead],
    summary="List allowed_email_domains",
)
async def list_allowed_email_domains(
    db: DbSession,
    pagination: Pagination,
    sorting: Sorting,
    include_deleted: Annotated[bool, Query(description="Include soft-deleted records")] = False,
) -> PaginatedResponse[AllowedEmailDomainRead]:
    """List allowed_email_domains with pagination and filtering."""
    service = AllowedEmailDomainService(db)

    items = await service.list(
        skip=pagination.skip,
        limit=pagination.limit,
        sort_by=sorting.sort_by,
        sort_order=sorting.sort_order,
        include_deleted=include_deleted,
    )

    total = await service.count(include_deleted=include_deleted)
    pages = (total + pagination.page_size - 1) // pagination.page_size

    return PaginatedResponse(
        items=[AllowedEmailDomainRead.model_validate(item) for item in items],
        total=total,
        page=pagination.page,
        page_size=pagination.page_size,
        pages=pages,
    )


@router.get(
    "/{id}",
    response_model=AllowedEmailDomainRead,
    summary="Get allowed_email_domain",
)
async def get_allowed_email_domain(
    db: DbSession,
    id: int,
) -> AllowedEmailDomainRead:
    """Get a allowed_email_domain by ID."""
    service = AllowedEmailDomainService(db)

    result = await service.get(id)
    if result is None:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="AllowedEmailDomain not found",
        )

    return AllowedEmailDomainRead.model_validate(result)


@router.post(
    "",
    response_model=AllowedEmailDomainRead,
    status_code=status.HTTP_201_CREATED,
    summary="Create allowed_email_domain",
)
async def create_allowed_email_domain(
    db: DbSession,
    data: AllowedEmailDomainCreate,
) -> AllowedEmailDomainRead:
    """Create a new allowed_email_domain."""
    service = AllowedEmailDomainService(db)

    result = await service.create(data=data)
    return AllowedEmailDomainRead.model_validate(result)


@router.patch(
    "/{id}",
    response_model=AllowedEmailDomainRead,
    summary="Update allowed_email_domain",
)
async def update_allowed_email_domain(
    db: DbSession,
    id: int,
    data: AllowedEmailDomainUpdate,
) -> AllowedEmailDomainRead:
    """Update a allowed_email_domain."""
    service = AllowedEmailDomainService(db)

    result = await service.update(id=id, data=data)
    if result is None:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="AllowedEmailDomain not found",
        )

    return AllowedEmailDomainRead.model_validate(result)


@router.delete(
    "/{id}",
    status_code=status.HTTP_204_NO_CONTENT,
    summary="Delete allowed_email_domain",
)
async def delete_allowed_email_domain(
    db: DbSession,
    id: int,
    hard: Annotated[bool, Query(description="Permanently delete")] = False,
) -> None:
    """Delete a allowed_email_domain."""
    service = AllowedEmailDomainService(db)

    success = await service.delete(id=id, soft=not hard and False)
    if not success:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="AllowedEmailDomain not found",
        )


@router.post(
    "/bulk",
    response_model=list[AllowedEmailDomainRead],
    status_code=status.HTTP_201_CREATED,
    summary="Bulk create allowed_email_domains",
)
async def bulk_create_allowed_email_domains(
    db: DbSession,
    data: list[AllowedEmailDomainCreate],
) -> list[AllowedEmailDomainRead]:
    """Create multiple allowed_email_domains in a single request."""
    service = AllowedEmailDomainService(db)

    results = await service.create_many(data=data)
    return [AllowedEmailDomainRead.model_validate(item) for item in results]


@router.patch(
    "/bulk",
    summary="Bulk update allowed_email_domains",
)
async def bulk_update_allowed_email_domains(
    db: DbSession,
    ids: Annotated[list[int], Query(description="IDs to update")],
    data: AllowedEmailDomainUpdate,
) -> dict[str, int]:
    """Update multiple allowed_email_domains with the same data."""
    service = AllowedEmailDomainService(db)

    count = await service.update_many(ids=ids, data=data)
    return {"updated": count}


@router.delete(
    "/bulk",
    summary="Bulk delete allowed_email_domains",
)
async def bulk_delete_allowed_email_domains(
    db: DbSession,
    ids: Annotated[list[int], Query(description="IDs to delete")],
    hard: Annotated[bool, Query(description="Permanently delete")] = False,
) -> dict[str, int]:
    """Delete multiple allowed_email_domains."""
    service = AllowedEmailDomainService(db)

    count = await service.delete_many(ids=ids, soft=not hard and False)
    return {"deleted": count}


__all__ = ["router"]
