"""REST API routes for Subdomain.

⚠️ AUTO-GENERATED BY PRISM - DO NOT EDIT
Extend this router in api/rest/subdomain.py
"""

from __future__ import annotations

from typing import Annotated

from fastapi import APIRouter, HTTPException, Query, status

from prisme_api.schemas.base import PaginatedResponse
from prisme_api.schemas.subdomain import (
    SubdomainCreate,
    SubdomainRead,
    SubdomainUpdate,
)
from prisme_api.services.subdomain import SubdomainService

from .deps import DbSession, Pagination, Sorting

router = APIRouter(prefix="/subdomains", tags=["subdomains"])


@router.get(
    "",
    response_model=PaginatedResponse[SubdomainRead],
    summary="List subdomains",
)
async def list_subdomains(
    db: DbSession,
    pagination: Pagination,
    sorting: Sorting,
    include_deleted: Annotated[bool, Query(description="Include soft-deleted records")] = False,
) -> PaginatedResponse[SubdomainRead]:
    """List subdomains with pagination and filtering."""
    service = SubdomainService(db)

    items = await service.list(
        skip=pagination.skip,
        limit=pagination.limit,
        sort_by=sorting.sort_by,
        sort_order=sorting.sort_order,
        include_deleted=include_deleted,
    )

    total = await service.count(include_deleted=include_deleted)
    pages = (total + pagination.page_size - 1) // pagination.page_size

    return PaginatedResponse(
        items=[SubdomainRead.model_validate(item) for item in items],
        total=total,
        page=pagination.page,
        page_size=pagination.page_size,
        pages=pages,
    )


@router.get(
    "/{id}",
    response_model=SubdomainRead,
    summary="Get subdomain",
)
async def get_subdomain(
    db: DbSession,
    id: int,
) -> SubdomainRead:
    """Get a subdomain by ID."""
    service = SubdomainService(db)

    result = await service.get(id)
    if result is None:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Subdomain not found",
        )

    return SubdomainRead.model_validate(result)


@router.post(
    "",
    response_model=SubdomainRead,
    status_code=status.HTTP_201_CREATED,
    summary="Create subdomain",
)
async def create_subdomain(
    db: DbSession,
    data: SubdomainCreate,
) -> SubdomainRead:
    """Create a new subdomain."""
    service = SubdomainService(db)

    result = await service.create(data=data)
    return SubdomainRead.model_validate(result)


@router.patch(
    "/{id}",
    response_model=SubdomainRead,
    summary="Update subdomain",
)
async def update_subdomain(
    db: DbSession,
    id: int,
    data: SubdomainUpdate,
) -> SubdomainRead:
    """Update a subdomain."""
    service = SubdomainService(db)

    result = await service.update(id=id, data=data)
    if result is None:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Subdomain not found",
        )

    return SubdomainRead.model_validate(result)


@router.delete(
    "/{id}",
    status_code=status.HTTP_204_NO_CONTENT,
    summary="Delete subdomain",
)
async def delete_subdomain(
    db: DbSession,
    id: int,
    hard: Annotated[bool, Query(description="Permanently delete")] = False,
) -> None:
    """Delete a subdomain."""
    service = SubdomainService(db)

    success = await service.delete(id=id, soft=not hard and False)
    if not success:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Subdomain not found",
        )


@router.post(
    "/bulk",
    response_model=list[SubdomainRead],
    status_code=status.HTTP_201_CREATED,
    summary="Bulk create subdomains",
)
async def bulk_create_subdomains(
    db: DbSession,
    data: list[SubdomainCreate],
) -> list[SubdomainRead]:
    """Create multiple subdomains in a single request."""
    service = SubdomainService(db)

    results = await service.create_many(data=data)
    return [SubdomainRead.model_validate(item) for item in results]


@router.patch(
    "/bulk",
    summary="Bulk update subdomains",
)
async def bulk_update_subdomains(
    db: DbSession,
    ids: Annotated[list[int], Query(description="IDs to update")],
    data: SubdomainUpdate,
) -> dict[str, int]:
    """Update multiple subdomains with the same data."""
    service = SubdomainService(db)

    count = await service.update_many(ids=ids, data=data)
    return {"updated": count}


@router.delete(
    "/bulk",
    summary="Bulk delete subdomains",
)
async def bulk_delete_subdomains(
    db: DbSession,
    ids: Annotated[list[int], Query(description="IDs to delete")],
    hard: Annotated[bool, Query(description="Permanently delete")] = False,
) -> dict[str, int]:
    """Delete multiple subdomains."""
    service = SubdomainService(db)

    count = await service.delete_many(ids=ids, soft=not hard and False)
    return {"deleted": count}


__all__ = ["router"]
