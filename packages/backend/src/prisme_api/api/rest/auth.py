"""Authentik authentication routes.

⚠️ AUTO-GENERATED BY PRISM - DO NOT EDIT
Endpoints for OIDC authentication flow with Authentik.
"""

from __future__ import annotations

import secrets
from typing import Annotated

from fastapi import APIRouter, Cookie, Depends, HTTPException, Response, status
from fastapi.responses import RedirectResponse
from sqlalchemy import select
from sqlalchemy.ext.asyncio import AsyncSession

from prisme_api.auth.config import authentik_settings
from prisme_api.auth.dependencies import CurrentActiveUser
from prisme_api.auth.oidc import OIDCError, oidc_client
from prisme_api.database import get_db
from prisme_api.models.user import User
from prisme_api.schemas.auth import UserResponse

router = APIRouter(prefix="/auth", tags=["authentication"])

# In-memory state store (use Redis in production for distributed systems)
_state_store: dict[str, dict] = {}


@router.get("/login")
async def login() -> RedirectResponse:
    """Initiate OIDC login flow.

    Generates state and nonce, stores them for verification,
    and redirects to Authentik authorization endpoint.

    Returns:
        Redirect to Authentik authorization URL
    """
    state = secrets.token_urlsafe(32)
    nonce = secrets.token_urlsafe(32)

    # Store state and nonce for verification on callback
    _state_store[state] = {"nonce": nonce}

    authorization_url = oidc_client.get_authorization_url(
        state=state,
        nonce=nonce,
    )

    return RedirectResponse(url=authorization_url, status_code=status.HTTP_302_FOUND)


@router.get("/callback")
async def callback(
    code: str,
    state: str,
    db: Annotated[AsyncSession, Depends(get_db)],
) -> RedirectResponse:
    """Handle OIDC callback from Authentik.

    Exchanges authorization code for tokens, validates ID token,
    creates/updates local user, and sets session cookie.

    Args:
        code: Authorization code from Authentik
        state: State parameter for CSRF verification
        db: Database session

    Returns:
        Redirect to application home with session cookie set

    Raises:
        HTTPException: If state is invalid or token exchange fails
    """
    # Verify state
    stored = _state_store.pop(state, None)
    if not stored:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Invalid or expired state parameter",
        )

    nonce = stored.get("nonce")

    try:
        # Exchange code for tokens
        tokens = await oidc_client.exchange_code(code)

        id_token = tokens.get("id_token")
        if not id_token:
            raise OIDCError("No ID token in response")

        # Validate ID token
        claims = await oidc_client.validate_id_token(id_token, nonce=nonce)

        # Get or create local user
        authentik_id = claims.get("sub")
        result = await db.execute(select(User).where(User.authentik_id == authentik_id))
        user = result.scalar_one_or_none()

        if not user:
            # Create new user from claims
            email = claims.get("email", f"{claims.get('preferred_username', 'user')}@local")
            username = claims.get("preferred_username", authentik_id)
            groups = claims.get("groups", [])
            roles = groups if groups else ["user"]

            user = User(
                authentik_id=authentik_id,
                email=email,
                username=username,
                is_active=True,
                roles=roles,
            )
            db.add(user)
            await db.commit()

        # Set session cookie and redirect
        response = RedirectResponse(
            url="/",
            status_code=status.HTTP_302_FOUND,
        )

        response.set_cookie(
            key=authentik_settings.session_cookie_name,
            value=id_token,
            max_age=authentik_settings.session_max_age,
            httponly=True,
            secure=True,
            samesite="lax",
        )

        return response

    except OIDCError as e:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=f"Authentication failed: {e}",
        ) from e


@router.get("/logout")
async def logout(
    response: Response,
    session_token: str | None = Cookie(
        None,
        alias=authentik_settings.session_cookie_name,
    ),
) -> RedirectResponse:
    """Logout and redirect to Authentik end session.

    Clears local session cookie and redirects to Authentik
    logout endpoint to end the SSO session.

    Args:
        response: FastAPI response for clearing cookie
        session_token: Current session token (ID token)

    Returns:
        Redirect to Authentik logout URL
    """
    # Get logout URL with ID token hint
    logout_url = oidc_client.get_logout_url(id_token_hint=session_token)

    # Create redirect response
    redirect = RedirectResponse(
        url=logout_url,
        status_code=status.HTTP_302_FOUND,
    )

    # Clear session cookie
    redirect.delete_cookie(
        key=authentik_settings.session_cookie_name,
        httponly=True,
        secure=True,
        samesite="lax",
    )

    return redirect


@router.post("/logout")
async def logout_post(
    response: Response,
    session_token: str | None = Cookie(
        None,
        alias=authentik_settings.session_cookie_name,
    ),
) -> dict[str, str]:
    """Logout via POST (for API clients).

    Clears session cookie without redirect.

    Args:
        response: FastAPI response for clearing cookie
        session_token: Current session token

    Returns:
        Success message with logout URL for client-side redirect
    """
    # Clear session cookie
    response.delete_cookie(
        key=authentik_settings.session_cookie_name,
        httponly=True,
        secure=True,
        samesite="lax",
    )

    return {
        "message": "Logged out successfully",
        "logout_url": oidc_client.get_logout_url(id_token_hint=session_token),
    }


@router.get("/me", response_model=UserResponse)
async def get_current_user_info(
    current_user: CurrentActiveUser,
) -> UserResponse:
    """Get current authenticated user information.

    Args:
        current_user: Authenticated user from middleware

    Returns:
        User data
    """
    return UserResponse.model_validate(current_user)


@router.post("/refresh")
async def refresh_session(
    response: Response,
    session_token: str | None = Cookie(
        None,
        alias=authentik_settings.session_cookie_name,
    ),
) -> dict[str, str]:
    """Refresh the session using stored refresh token.

    Note: This endpoint requires the refresh token to be stored
    (e.g., in Redis or database). For stateless sessions, the
    frontend should redirect to /auth/login when the session expires.

    Args:
        response: FastAPI response for setting new cookie
        session_token: Current session token

    Returns:
        Success message

    Raises:
        HTTPException: If refresh fails
    """
    if not session_token:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="No session to refresh",
        )

    # For stateless sessions, redirect to login
    # In a production system, you would store and use refresh tokens
    raise HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Session expired, please login again",
    )
