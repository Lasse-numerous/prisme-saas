"""MCP tools for AllowedEmailDomain.

⚠️ AUTO-GENERATED BY PRISM - DO NOT EDIT
"""

from __future__ import annotations

from collections.abc import AsyncGenerator
from contextlib import asynccontextmanager
from typing import Any

from fastmcp import FastMCP
from sqlalchemy.ext.asyncio import AsyncSession

from prisme_api.database import async_session
from prisme_api.schemas.allowed_email_domain import (
    AllowedEmailDomainCreate,
    AllowedEmailDomainUpdate,
)
from prisme_api.services.allowed_email_domain import AllowedEmailDomainService


@asynccontextmanager
async def get_db() -> AsyncGenerator[AsyncSession]:
    """Get database session for MCP tools."""
    async with async_session() as session:
        try:
            yield session
            await session.commit()
        except Exception:
            await session.rollback()
            raise


def register_allowed_email_domain_tools(mcp: FastMCP) -> None:
    """Register AllowedEmailDomain tools with the MCP server."""

    @mcp.tool(description="List allowed_email_domains with optional filtering and pagination")
    async def allowed_email_domain_list(
        page: int = 1,
        page_size: int = 20,
    ) -> dict[str, Any]:
        """List allowed_email_domains.

        Args:
            page: Page number (starts at 1)
            page_size: Number of items per page (max 100)
        Returns:
            Dictionary with items, total count, and pagination info.
        """
        async with get_db() as db:
            service = AllowedEmailDomainService(db)
            skip = (page - 1) * min(page_size, 100)
            limit = min(page_size, 100)
            items = await service.list(skip=skip, limit=limit)
            total = await service.count()
            return {
                "items": [
                    {k: v for k, v in item.__dict__.items() if not k.startswith("_")}
                    for item in items
                ],
                "total": total,
                "page": page,
                "page_size": limit,
                "has_more": skip + len(items) < total,
            }

    @mcp.tool(description="Get a allowed_email_domain by ID")
    async def allowed_email_domain_get(id: int) -> dict[str, Any] | None:
        """Get a allowed_email_domain by ID.

        Args:
            id: The allowed_email_domain ID.

        Returns:
            The allowed_email_domain data or None if not found.
        """
        async with get_db() as db:
            service = AllowedEmailDomainService(db)
            result = await service.get(id)
            if result is None:
                return None
            return {k: v for k, v in result.__dict__.items() if not k.startswith("_")}

    @mcp.tool(description="Create a new allowed_email_domain")
    async def allowed_email_domain_create(
        domain: str,  # Email domain (e.g., 'example.com')
        is_active: bool | None = True,  # Whether this domain is currently allowed
        description: str | None = None,  # Optional description/notes about this domain
    ) -> dict[str, Any]:
        """Create a new allowed_email_domain.

        Args:
            domain: Email domain (e.g., 'example.com')
            is_active: Whether this domain is currently allowed (optional)
            description: Optional description/notes about this domain (optional)
        Returns:
            The created allowed_email_domain data.
        """
        async with get_db() as db:
            service = AllowedEmailDomainService(db)
            data = AllowedEmailDomainCreate(
                domain=domain, is_active=is_active, description=description
            )
            result = await service.create(data=data)
            return {k: v for k, v in result.__dict__.items() if not k.startswith("_")}

    @mcp.tool(description="Update an existing allowed_email_domain")
    async def allowed_email_domain_update(
        id: int,
        domain: str | None = None,  # Email domain (e.g., 'example.com')
        is_active: bool | None = None,  # Whether this domain is currently allowed
        description: str | None = None,  # Optional description/notes about this domain
    ) -> dict[str, Any] | None:
        """Update an existing allowed_email_domain.

        Args:
            id: The allowed_email_domain ID to update.
            domain: Email domain (e.g., 'example.com')
            is_active: Whether this domain is currently allowed (optional)
            description: Optional description/notes about this domain (optional)
        Returns:
            The updated allowed_email_domain data or None if not found.
        """
        async with get_db() as db:
            service = AllowedEmailDomainService(db)
            # Build update data from non-None values
            update_fields = {}
            if domain is not None:
                update_fields["domain"] = domain
            if is_active is not None:
                update_fields["is_active"] = is_active
            if description is not None:
                update_fields["description"] = description
            data = AllowedEmailDomainUpdate(**update_fields)
            result = await service.update(id=id, data=data)
            if result is None:
                return None
            return {k: v for k, v in result.__dict__.items() if not k.startswith("_")}

    @mcp.tool(description="Delete a allowed_email_domain")
    async def allowed_email_domain_delete(id: int) -> bool:
        """Delete a allowed_email_domain.

        Args:
            id: The allowed_email_domain ID to delete.

        Returns:
            True if deleted, False if not found.
        """
        async with get_db() as db:
            service = AllowedEmailDomainService(db)
            return await service.delete(id=id)


__all__ = ["register_allowed_email_domain_tools"]
