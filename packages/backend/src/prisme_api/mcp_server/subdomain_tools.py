"""MCP tools for Subdomain.

⚠️ AUTO-GENERATED BY PRISM - DO NOT EDIT

SECURITY: All tools require admin API key authentication.
Pass _api_key parameter with MCP_ADMIN_API_KEY value.
"""

from __future__ import annotations

from collections.abc import AsyncGenerator
from contextlib import asynccontextmanager
from typing import Any

from fastmcp import FastMCP
from sqlalchemy.ext.asyncio import AsyncSession

from prisme_api.database import async_session
from prisme_api.mcp_server.auth import require_mcp_auth
from prisme_api.schemas.subdomain import SubdomainCreate, SubdomainFilter, SubdomainUpdate
from prisme_api.services.subdomain import SubdomainService


@asynccontextmanager
async def get_db() -> AsyncGenerator[AsyncSession]:
    """Get database session for MCP tools."""
    async with async_session() as session:
        try:
            yield session
            await session.commit()
        except Exception:
            await session.rollback()
            raise


def register_subdomain_tools(mcp: FastMCP) -> None:
    """Register Subdomain tools with the MCP server."""

    @mcp.tool(description="List subdomains with optional filtering and pagination (admin only)")
    @require_mcp_auth
    async def subdomain_list(
        page: int = 1,
        page_size: int = 20,
        owner_id: int | None = None,  # Filter by owner user ID
        status: str | None = None,  # Filter by status
        _api_key: str = "",  # Admin API key for authentication
    ) -> dict[str, Any]:
        """List subdomains.

        Args:
            page: Page number (starts at 1)
            page_size: Number of items per page (max 100)
            owner_id: Filter by owner user ID (optional)
            status: Filter by status (optional)
        Returns:
            Dictionary with items, total count, and pagination info.
        """
        async with get_db() as db:
            service = SubdomainService(db)
            skip = (page - 1) * min(page_size, 100)
            limit = min(page_size, 100)
            # Build filter object from parameters
            filters = {}
            if owner_id is not None:
                filters["owner_id"] = owner_id
            if status is not None:
                filters["status"] = status
            filter_obj = SubdomainFilter(**filters) if filters else None

            items = await service.list(skip=skip, limit=limit, filters=filter_obj)
            total = await service.count_filtered(filters=filter_obj)
            return {
                "items": [
                    {k: v for k, v in item.__dict__.items() if not k.startswith("_")}
                    for item in items
                ],
                "total": total,
                "page": page,
                "page_size": limit,
                "has_more": skip + len(items) < total,
            }

    @mcp.tool(description="Get a subdomain by ID (admin only)")
    @require_mcp_auth
    async def subdomain_get(
        id: int,
        _api_key: str = "",  # Admin API key for authentication
    ) -> dict[str, Any] | None:
        """Get a subdomain by ID.

        Args:
            id: The subdomain ID.

        Returns:
            The subdomain data or None if not found.
        """
        async with get_db() as db:
            service = SubdomainService(db)
            result = await service.get(id)
            if result is None:
                return None
            return {k: v for k, v in result.__dict__.items() if not k.startswith("_")}

    @mcp.tool(description="Create a new subdomain (admin only)")
    @require_mcp_auth
    async def subdomain_create(
        name: str,  # Subdomain name (e.g., 'myapp')
        owner_id: int | None = None,  # The user who owns this subdomain
        ip_address: str | None = None,  # IPv4 address for the A record
        status: str | None = "reserved",  # Current status of the subdomain
        dns_record_id: str | None = None,  # Hetzner DNS record ID
        _api_key: str = "",  # Admin API key for authentication
    ) -> dict[str, Any]:
        """Create a new subdomain.

        Args:
            name: Subdomain name (e.g., 'myapp')
            owner_id: The user who owns this subdomain (optional)
            ip_address: IPv4 address for the A record (optional)
            status: Current status of the subdomain (optional)
            dns_record_id: Hetzner DNS record ID (optional)
        Returns:
            The created subdomain data.
        """
        async with get_db() as db:
            service = SubdomainService(db)
            data = SubdomainCreate(
                name=name,
                owner_id=owner_id,
                ip_address=ip_address,
                status=status,
                dns_record_id=dns_record_id,
            )
            result = await service.create(data=data)
            return {k: v for k, v in result.__dict__.items() if not k.startswith("_")}

    @mcp.tool(description="Update an existing subdomain (admin only)")
    @require_mcp_auth
    async def subdomain_update(
        id: int,
        name: str | None = None,  # Subdomain name (e.g., 'myapp')
        owner_id: int | None = None,  # The user who owns this subdomain
        ip_address: str | None = None,  # IPv4 address for the A record
        status: str | None = None,  # Current status of the subdomain
        dns_record_id: str | None = None,  # Hetzner DNS record ID
        _api_key: str = "",  # Admin API key for authentication
    ) -> dict[str, Any] | None:
        """Update an existing subdomain.

        Args:
            id: The subdomain ID to update.
            name: Subdomain name (e.g., 'myapp')
            owner_id: The user who owns this subdomain (optional)
            ip_address: IPv4 address for the A record (optional)
            status: Current status of the subdomain (optional)
            dns_record_id: Hetzner DNS record ID (optional)
        Returns:
            The updated subdomain data or None if not found.
        """
        async with get_db() as db:
            service = SubdomainService(db)
            # Build update data from non-None values
            update_fields = {}
            if name is not None:
                update_fields["name"] = name
            if owner_id is not None:
                update_fields["owner_id"] = owner_id
            if ip_address is not None:
                update_fields["ip_address"] = ip_address
            if status is not None:
                update_fields["status"] = status
            if dns_record_id is not None:
                update_fields["dns_record_id"] = dns_record_id
            data = SubdomainUpdate(**update_fields)
            result = await service.update(id=id, data=data)
            if result is None:
                return None
            return {k: v for k, v in result.__dict__.items() if not k.startswith("_")}

    @mcp.tool(description="Delete a subdomain (admin only)")
    @require_mcp_auth
    async def subdomain_delete(
        id: int,
        _api_key: str = "",  # Admin API key for authentication
    ) -> dict[str, Any]:
        """Delete a subdomain.

        Args:
            id: The subdomain ID to delete.

        Returns:
            Dictionary with success status.
        """
        async with get_db() as db:
            service = SubdomainService(db)
            deleted = await service.delete(id=id)
            return {"deleted": deleted, "id": id}


__all__ = ["register_subdomain_tools"]
