"""MCP tools for User.

⚠️ AUTO-GENERATED BY PRISM - DO NOT EDIT

SECURITY: All tools require admin API key authentication.
Pass _api_key parameter with MCP_ADMIN_API_KEY value.
"""

from __future__ import annotations

from collections.abc import AsyncGenerator
from contextlib import asynccontextmanager
from typing import Any

from fastmcp import FastMCP
from sqlalchemy.ext.asyncio import AsyncSession

from prisme_api.database import async_session
from prisme_api.mcp_server.auth import require_mcp_auth
from prisme_api.schemas.user import UserCreate, UserFilter, UserUpdate
from prisme_api.services.user import UserService


@asynccontextmanager
async def get_db() -> AsyncGenerator[AsyncSession]:
    """Get database session for MCP tools."""
    async with async_session() as session:
        try:
            yield session
            await session.commit()
        except Exception:
            await session.rollback()
            raise


def register_user_tools(mcp: FastMCP) -> None:
    """Register User tools with the MCP server."""

    @mcp.tool(description="List users with optional filtering and pagination (admin only)")
    @require_mcp_auth
    async def user_list(
        page: int = 1,
        page_size: int = 20,
        api_keys_id: int | None = None,  # Filter by related APIKey ID
        subdomains_id: int | None = None,  # Filter by related Subdomain ID
        _api_key: str = "",  # Admin API key for authentication
    ) -> dict[str, Any]:
        """List users.

        Args:
            page: Page number (starts at 1)
            page_size: Number of items per page (max 100)
            api_keys_id: Filter by related APIKey ID (optional)
            subdomains_id: Filter by related Subdomain ID (optional)
        Returns:
            Dictionary with items, total count, and pagination info.
        """
        async with get_db() as db:
            service = UserService(db)
            skip = (page - 1) * min(page_size, 100)
            limit = min(page_size, 100)
            # Build filter object from parameters
            filters = {}
            if api_keys_id is not None:
                filters["api_keys_id"] = api_keys_id
            if subdomains_id is not None:
                filters["subdomains_id"] = subdomains_id
            filter_obj = UserFilter(**filters) if filters else None

            items = await service.list(skip=skip, limit=limit, filters=filter_obj)
            total = await service.count_filtered(filters=filter_obj)
            return {
                "items": [
                    {k: v for k, v in item.__dict__.items() if not k.startswith("_")}
                    for item in items
                ],
                "total": total,
                "page": page,
                "page_size": limit,
                "has_more": skip + len(items) < total,
            }

    @mcp.tool(description="Get a user by ID (admin only)")
    @require_mcp_auth
    async def user_get(
        id: int,
        _api_key: str = "",  # Admin API key for authentication
    ) -> dict[str, Any] | None:
        """Get a user by ID.

        Args:
            id: The user ID.

        Returns:
            The user data or None if not found.
        """
        async with get_db() as db:
            service = UserService(db)
            result = await service.get(id)
            if result is None:
                return None
            return {k: v for k, v in result.__dict__.items() if not k.startswith("_")}

    @mcp.tool(description="Create a new user (admin only)")
    @require_mcp_auth
    async def user_create(
        email: str,  # User email address
        password_hash: str | None = None,  # Hashed password (bcrypt)
        email_verified: bool | None = False,  # Whether email has been verified
        email_verification_token: str | None = None,  # Token for email verification
        mfa_enabled: bool | None = False,  # Whether MFA is enabled
        mfa_secret: str | None = None,  # TOTP MFA secret
        subdomain_limit: int | None = 5,  # Maximum number of subdomains allowed
        is_admin: bool | None = False,  # Whether user has admin privileges
        api_keys_ids: list[int] | None = None,  # IDs of related APIKey entities
        subdomains_ids: list[int] | None = None,  # IDs of related Subdomain entities
        _api_key: str = "",  # Admin API key for authentication
    ) -> dict[str, Any]:
        """Create a new user.

        Args:
            email: User email address
            password_hash: Hashed password (bcrypt) (optional)
            email_verified: Whether email has been verified (optional)
            email_verification_token: Token for email verification (optional)
            mfa_enabled: Whether MFA is enabled (optional)
            mfa_secret: TOTP MFA secret (optional)
            subdomain_limit: Maximum number of subdomains allowed (optional)
            is_admin: Whether user has admin privileges (optional)
            api_keys_ids: List of APIKey IDs to link (optional)
            subdomains_ids: List of Subdomain IDs to link (optional)
        Returns:
            The created user data.
        """
        async with get_db() as db:
            service = UserService(db)
            data = UserCreate(
                email=email,
                password_hash=password_hash,
                email_verified=email_verified,
                email_verification_token=email_verification_token,
                mfa_enabled=mfa_enabled,
                mfa_secret=mfa_secret,
                subdomain_limit=subdomain_limit,
                is_admin=is_admin,
            )
            result = await service.create(data=data)
            return {k: v for k, v in result.__dict__.items() if not k.startswith("_")}

    @mcp.tool(description="Update an existing user (admin only)")
    @require_mcp_auth
    async def user_update(
        id: int,
        email: str | None = None,  # User email address
        password_hash: str | None = None,  # Hashed password (bcrypt)
        email_verified: bool | None = None,  # Whether email has been verified
        email_verification_token: str | None = None,  # Token for email verification
        mfa_enabled: bool | None = None,  # Whether MFA is enabled
        mfa_secret: str | None = None,  # TOTP MFA secret
        subdomain_limit: int | None = None,  # Maximum number of subdomains allowed
        is_admin: bool | None = None,  # Whether user has admin privileges
        api_keys_ids: list[int] | None = None,  # IDs of related APIKey entities
        subdomains_ids: list[int] | None = None,  # IDs of related Subdomain entities
        _api_key: str = "",  # Admin API key for authentication
    ) -> dict[str, Any] | None:
        """Update an existing user.

        Args:
            id: The user ID to update.
            email: User email address
            password_hash: Hashed password (bcrypt) (optional)
            email_verified: Whether email has been verified (optional)
            email_verification_token: Token for email verification (optional)
            mfa_enabled: Whether MFA is enabled (optional)
            mfa_secret: TOTP MFA secret (optional)
            subdomain_limit: Maximum number of subdomains allowed (optional)
            is_admin: Whether user has admin privileges (optional)
            api_keys_ids: List of APIKey IDs to link (optional)
            subdomains_ids: List of Subdomain IDs to link (optional)
        Returns:
            The updated user data or None if not found.
        """
        async with get_db() as db:
            service = UserService(db)
            # Build update data from non-None values
            update_fields = {}
            if email is not None:
                update_fields["email"] = email
            if password_hash is not None:
                update_fields["password_hash"] = password_hash
            if email_verified is not None:
                update_fields["email_verified"] = email_verified
            if email_verification_token is not None:
                update_fields["email_verification_token"] = email_verification_token
            if mfa_enabled is not None:
                update_fields["mfa_enabled"] = mfa_enabled
            if mfa_secret is not None:
                update_fields["mfa_secret"] = mfa_secret
            if subdomain_limit is not None:
                update_fields["subdomain_limit"] = subdomain_limit
            if is_admin is not None:
                update_fields["is_admin"] = is_admin
            data = UserUpdate(**update_fields)
            result = await service.update(id=id, data=data)
            if result is None:
                return None
            return {k: v for k, v in result.__dict__.items() if not k.startswith("_")}

    @mcp.tool(description="Delete a user (admin only)")
    @require_mcp_auth
    async def user_delete(
        id: int,
        _api_key: str = "",  # Admin API key for authentication
    ) -> dict[str, Any]:
        """Delete a user.

        Args:
            id: The user ID to delete.

        Returns:
            Dictionary with success status.
        """
        async with get_db() as db:
            service = UserService(db)
            deleted = await service.delete(id=id)
            return {"deleted": deleted, "id": id}


__all__ = ["register_user_tools"]
