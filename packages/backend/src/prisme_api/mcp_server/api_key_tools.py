"""MCP tools for APIKey.

⚠️ AUTO-GENERATED BY PRISM - DO NOT EDIT

SECURITY: All tools require admin API key authentication.
Pass _api_key parameter with MCP_ADMIN_API_KEY value.
"""

from __future__ import annotations

from collections.abc import AsyncGenerator
from contextlib import asynccontextmanager
from typing import Any

from fastmcp import FastMCP
from sqlalchemy.ext.asyncio import AsyncSession

from prisme_api.database import async_session
from prisme_api.mcp_server.auth import require_mcp_auth
from prisme_api.schemas.api_key import APIKeyCreate, APIKeyFilter, APIKeyUpdate
from prisme_api.services.api_key import APIKeyService


@asynccontextmanager
async def get_db() -> AsyncGenerator[AsyncSession]:
    """Get database session for MCP tools."""
    async with async_session() as session:
        try:
            yield session
            await session.commit()
        except Exception:
            await session.rollback()
            raise


def register_api_key_tools(mcp: FastMCP) -> None:
    """Register APIKey tools with the MCP server."""

    @mcp.tool(description="List API keys with optional filtering and pagination (admin only)")
    @require_mcp_auth
    async def api_key_list(
        page: int = 1,
        page_size: int = 20,
        user_id: int | None = None,  # Filter by user ID
        _api_key: str = "",  # Admin API key for authentication
    ) -> dict[str, Any]:
        """List API keys.

        Args:
            page: Page number (starts at 1)
            page_size: Number of items per page (max 100)
            user_id: Filter by user ID (optional)
        Returns:
            Dictionary with items, total count, and pagination info.
        """
        async with get_db() as db:
            service = APIKeyService(db)
            skip = (page - 1) * min(page_size, 100)
            limit = min(page_size, 100)
            # Build filter object from parameters
            filters = {}
            if user_id is not None:
                filters["user_id"] = user_id
            filter_obj = APIKeyFilter(**filters) if filters else None

            items = await service.list(skip=skip, limit=limit, filters=filter_obj)
            total = await service.count_filtered(filters=filter_obj)
            return {
                "items": [
                    {k: v for k, v in item.__dict__.items() if not k.startswith("_")}
                    for item in items
                ],
                "total": total,
                "page": page,
                "page_size": limit,
                "has_more": skip + len(items) < total,
            }

    @mcp.tool(description="Get an API key by ID (admin only)")
    @require_mcp_auth
    async def api_key_get(
        id: int,
        _api_key: str = "",  # Admin API key for authentication
    ) -> dict[str, Any] | None:
        """Get an API key by ID.

        Args:
            id: The API key ID.

        Returns:
            The API key data or None if not found.
        """
        async with get_db() as db:
            service = APIKeyService(db)
            result = await service.get(id)
            if result is None:
                return None
            return {k: v for k, v in result.__dict__.items() if not k.startswith("_")}

    @mcp.tool(description="Create a new API key (admin only)")
    @require_mcp_auth
    async def api_key_create(
        user_id: int,  # The user who owns this API key
        key_hash: str,  # Hashed API key (SHA256)
        key_prefix: str,  # API key prefix for identification (e.g., prisme_live_sk_xxx)
        name: str,  # Human-readable name for the API key
        last_used_at: str | None = None,  # Last time this API key was used
        expires_at: str | None = None,  # When this API key expires (null = never)
        is_active: bool | None = True,  # Whether this API key is active
        _api_key: str = "",  # Admin API key for authentication
    ) -> dict[str, Any]:
        """Create a new API key.

        Args:
            user_id: The user who owns this API key
            key_hash: Hashed API key (SHA256)
            key_prefix: API key prefix for identification (e.g., prisme_live_sk_xxx)
            name: Human-readable name for the API key
            last_used_at: Last time this API key was used (optional)
            expires_at: When this API key expires (null = never) (optional)
            is_active: Whether this API key is active (optional)
        Returns:
            The created API key data.
        """
        async with get_db() as db:
            service = APIKeyService(db)
            data = APIKeyCreate(
                user_id=user_id,
                key_hash=key_hash,
                key_prefix=key_prefix,
                name=name,
                last_used_at=last_used_at,
                expires_at=expires_at,
                is_active=is_active,
            )
            result = await service.create(data=data)
            return {k: v for k, v in result.__dict__.items() if not k.startswith("_")}

    @mcp.tool(description="Update an existing API key (admin only)")
    @require_mcp_auth
    async def api_key_update(
        id: int,
        user_id: int | None = None,  # The user who owns this API key
        key_hash: str | None = None,  # Hashed API key (SHA256)
        key_prefix: str
        | None = None,  # API key prefix for identification (e.g., prisme_live_sk_xxx)
        name: str | None = None,  # Human-readable name for the API key
        last_used_at: str | None = None,  # Last time this API key was used
        expires_at: str | None = None,  # When this API key expires (null = never)
        is_active: bool | None = None,  # Whether this API key is active
        _api_key: str = "",  # Admin API key for authentication
    ) -> dict[str, Any] | None:
        """Update an existing API key.

        Args:
            id: The API key ID to update.
            user_id: The user who owns this API key
            key_hash: Hashed API key (SHA256)
            key_prefix: API key prefix for identification (e.g., prisme_live_sk_xxx)
            name: Human-readable name for the API key
            last_used_at: Last time this API key was used (optional)
            expires_at: When this API key expires (null = never) (optional)
            is_active: Whether this API key is active (optional)
        Returns:
            The updated API key data or None if not found.
        """
        async with get_db() as db:
            service = APIKeyService(db)
            # Build update data from non-None values
            update_fields = {}
            if user_id is not None:
                update_fields["user_id"] = user_id
            if key_hash is not None:
                update_fields["key_hash"] = key_hash
            if key_prefix is not None:
                update_fields["key_prefix"] = key_prefix
            if name is not None:
                update_fields["name"] = name
            if last_used_at is not None:
                update_fields["last_used_at"] = last_used_at
            if expires_at is not None:
                update_fields["expires_at"] = expires_at
            if is_active is not None:
                update_fields["is_active"] = is_active
            data = APIKeyUpdate(**update_fields)
            result = await service.update(id=id, data=data)
            if result is None:
                return None
            return {k: v for k, v in result.__dict__.items() if not k.startswith("_")}

    @mcp.tool(description="Delete an API key (admin only)")
    @require_mcp_auth
    async def api_key_delete(
        id: int,
        _api_key: str = "",  # Admin API key for authentication
    ) -> dict[str, Any]:
        """Delete an API key.

        Args:
            id: The API key ID to delete.

        Returns:
            Dictionary with success status.
        """
        async with get_db() as db:
            service = APIKeyService(db)
            deleted = await service.delete(id=id)
            return {"deleted": deleted, "id": id}


__all__ = ["register_api_key_tools"]
