"""Authentik OIDC client implementation.

AUTO-GENERATED BY PRISM - DO NOT EDIT
OIDC client for handling authentication flows with Authentik.
"""

from __future__ import annotations

import time
from typing import Any
from urllib.parse import urlencode

import httpx
from authlib.jose import JsonWebKey, jwt
from authlib.jose.errors import BadSignatureError, DecodeError, ExpiredTokenError

from prisme_api.auth.config import authentik_settings


class OIDCClient:
    """OIDC client for Authentik integration."""

    def __init__(self) -> None:
        """Initialize the OIDC client."""
        self.settings = authentik_settings
        self._jwks_cache: dict[str, Any] | None = None
        self._jwks_cache_time: float = 0
        self._jwks_cache_ttl: int = 3600  # Cache JWKS for 1 hour

    def get_authorization_url(
        self,
        state: str,
        nonce: str,
        scopes: list[str] | None = None,
    ) -> str:
        """Generate the authorization URL for initiating OIDC flow.

        Args:
            state: Random state parameter for CSRF protection
            nonce: Random nonce for replay attack protection
            scopes: OAuth scopes to request (defaults to openid email profile)

        Returns:
            Full authorization URL to redirect the user to
        """
        if scopes is None:
            scopes = ["openid", "email", "profile"]

        params = {
            "client_id": self.settings.client_id,
            "redirect_uri": self.settings.redirect_uri,
            "response_type": "code",
            "scope": " ".join(scopes),
            "state": state,
            "nonce": nonce,
        }

        return f"{self.settings.authorize_url}?{urlencode(params)}"

    async def exchange_code(self, code: str) -> dict[str, Any]:
        """Exchange authorization code for tokens.

        Args:
            code: Authorization code from callback

        Returns:
            Token response containing access_token, id_token, refresh_token

        Raises:
            OIDCError: If token exchange fails
        """
        async with httpx.AsyncClient() as client:
            response = await client.post(
                self.settings.token_url,
                data={
                    "grant_type": "authorization_code",
                    "client_id": self.settings.client_id,
                    "client_secret": self.settings.client_secret,
                    "code": code,
                    "redirect_uri": self.settings.redirect_uri,
                },
                headers={"Content-Type": "application/x-www-form-urlencoded"},
            )

            if response.status_code != 200:
                raise OIDCError(f"Token exchange failed: {response.text}")

            return response.json()

    async def refresh_tokens(self, refresh_token: str) -> dict[str, Any]:
        """Refresh tokens using refresh token.

        Args:
            refresh_token: Valid refresh token

        Returns:
            New token response

        Raises:
            OIDCError: If refresh fails
        """
        async with httpx.AsyncClient() as client:
            response = await client.post(
                self.settings.token_url,
                data={
                    "grant_type": "refresh_token",
                    "client_id": self.settings.client_id,
                    "client_secret": self.settings.client_secret,
                    "refresh_token": refresh_token,
                },
                headers={"Content-Type": "application/x-www-form-urlencoded"},
            )

            if response.status_code != 200:
                raise OIDCError(f"Token refresh failed: {response.text}")

            return response.json()

    async def get_userinfo(self, access_token: str) -> dict[str, Any]:
        """Fetch user info from Authentik userinfo endpoint.

        Args:
            access_token: Valid access token

        Returns:
            User information from Authentik

        Raises:
            OIDCError: If userinfo request fails
        """
        async with httpx.AsyncClient() as client:
            response = await client.get(
                self.settings.userinfo_url,
                headers={"Authorization": f"Bearer {access_token}"},
            )

            if response.status_code != 200:
                raise OIDCError(f"Userinfo request failed: {response.text}")

            return response.json()

    async def _get_jwks(self) -> dict[str, Any]:
        """Fetch and cache JWKS from Authentik.

        Returns:
            JWKS data

        Raises:
            OIDCError: If JWKS fetch fails
        """
        now = time.time()

        # Return cached JWKS if still valid
        if self._jwks_cache and (now - self._jwks_cache_time) < self._jwks_cache_ttl:
            return self._jwks_cache

        async with httpx.AsyncClient() as client:
            response = await client.get(self.settings.jwks_url)

            if response.status_code != 200:
                raise OIDCError(f"JWKS fetch failed: {response.text}")

            self._jwks_cache = response.json()
            self._jwks_cache_time = now

            return self._jwks_cache

    async def validate_id_token(
        self,
        id_token: str,
        nonce: str | None = None,
    ) -> dict[str, Any]:
        """Validate ID token and return claims.

        Args:
            id_token: JWT ID token from Authentik
            nonce: Expected nonce value (if provided during authorization)

        Returns:
            Decoded token claims

        Raises:
            OIDCError: If token validation fails
        """
        try:
            jwks_data = await self._get_jwks()
            jwks = JsonWebKey.import_key_set(jwks_data)

            claims = jwt.decode(
                id_token,
                jwks,
                claims_options={
                    "iss": {"essential": True, "value": self.settings.issuer_url.rstrip("/")},
                    "aud": {"essential": True, "value": self.settings.client_id},
                    "exp": {"essential": True},
                },
            )

            claims.validate()

            # Verify nonce if provided
            if nonce and claims.get("nonce") != nonce:
                raise OIDCError("Invalid nonce in ID token")

            return dict(claims)

        except ExpiredTokenError:
            raise OIDCError("ID token has expired") from None
        except BadSignatureError:
            raise OIDCError("ID token signature verification failed") from None
        except DecodeError as e:
            raise OIDCError(f"Failed to decode ID token: {e}") from e

    def get_logout_url(self, id_token_hint: str | None = None) -> str:
        """Generate the logout URL for ending the session.

        Args:
            id_token_hint: ID token to include as hint (optional)

        Returns:
            Logout URL to redirect the user to
        """
        params = {
            "post_logout_redirect_uri": self.settings.post_logout_redirect_uri,
        }

        if id_token_hint:
            params["id_token_hint"] = id_token_hint

        return f"{self.settings.logout_url}?{urlencode(params)}"


class OIDCError(Exception):
    """Exception raised for OIDC-related errors."""

    pass


# Global OIDC client instance
oidc_client = OIDCClient()
