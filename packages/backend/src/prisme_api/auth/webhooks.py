"""Authentik webhook handlers.

AUTO-GENERATED BY PRISM - DO NOT EDIT
Handles user sync webhooks from Authentik for local database updates.
"""

from __future__ import annotations

import hashlib
import hmac
import json
import logging
from typing import Any

from fastapi import APIRouter, Header, HTTPException, Request, status
from sqlalchemy import select
from sqlalchemy.ext.asyncio import AsyncSession

from prisme_api.auth.config import authentik_settings
from prisme_api.database import get_async_session
from prisme_api.models.user import User

logger = logging.getLogger(__name__)

router = APIRouter(prefix="/webhooks/authentik", tags=["webhooks"])


def verify_webhook_signature(
    payload: bytes,
    signature: str,
    secret: str,
) -> bool:
    """Verify HMAC signature from Authentik webhook.

    Args:
        payload: Raw request body
        signature: Signature from X-Authentik-Signature header
        secret: Webhook secret for HMAC verification

    Returns:
        True if signature is valid, False otherwise
    """
    if not signature or not secret:
        return False

    expected = hmac.new(
        secret.encode("utf-8"),
        payload,
        hashlib.sha256,
    ).hexdigest()

    return hmac.compare_digest(f"sha256={expected}", signature)


async def handle_user_created(data: dict[str, Any], db: AsyncSession) -> None:
    """Handle user.created webhook event.

    Args:
        data: Webhook payload data
        db: Database session
    """
    user_data = data.get("user", {})
    authentik_id = user_data.get("pk")
    email = user_data.get("email")
    username = user_data.get("username")

    if not authentik_id:
        logger.warning("User created webhook missing user pk")
        return

    # Check if user already exists
    result = await db.execute(select(User).where(User.authentik_id == authentik_id))
    existing_user = result.scalar_one_or_none()

    if existing_user:
        logger.info(f"User {authentik_id} already exists, skipping creation")
        return

    # Extract groups/roles from Authentik
    groups = user_data.get("groups", [])
    roles = [g.get("name") for g in groups if g.get("name")]
    if not roles:
        roles = ["user"]

    # Create local user record
    user = User(
        authentik_id=authentik_id,
        email=email or f"{username}@local",
        username=username,
        is_active=user_data.get("is_active", True),
        roles=roles,
    )

    db.add(user)
    await db.commit()
    logger.info(f"Created local user for Authentik user {authentik_id}")


async def handle_user_updated(data: dict[str, Any], db: AsyncSession) -> None:
    """Handle user.updated webhook event.

    Args:
        data: Webhook payload data
        db: Database session
    """
    user_data = data.get("user", {})
    authentik_id = user_data.get("pk")

    if not authentik_id:
        logger.warning("User updated webhook missing user pk")
        return

    # Find existing user
    result = await db.execute(select(User).where(User.authentik_id == authentik_id))
    user = result.scalar_one_or_none()

    if not user:
        logger.warning(f"User {authentik_id} not found for update, creating...")
        await handle_user_created(data, db)
        return

    # Update user fields
    if "email" in user_data:
        user.email = user_data["email"]
    if "username" in user_data:
        user.username = user_data["username"]
    if "is_active" in user_data:
        user.is_active = user_data["is_active"]

    # Update roles from groups
    groups = user_data.get("groups", [])
    if groups:
        roles = [g.get("name") for g in groups if g.get("name")]
        if roles:
            user.roles = roles

    await db.commit()
    logger.info(f"Updated local user for Authentik user {authentik_id}")


async def handle_user_deleted(data: dict[str, Any], db: AsyncSession) -> None:
    """Handle user.deleted webhook event.

    Args:
        data: Webhook payload data
        db: Database session
    """
    user_data = data.get("user", {})
    authentik_id = user_data.get("pk")

    if not authentik_id:
        logger.warning("User deleted webhook missing user pk")
        return

    # Find and deactivate user (soft delete)
    result = await db.execute(select(User).where(User.authentik_id == authentik_id))
    user = result.scalar_one_or_none()

    if not user:
        logger.warning(f"User {authentik_id} not found for deletion")
        return

    # Soft delete by deactivating
    user.is_active = False
    await db.commit()
    logger.info(f"Deactivated local user for deleted Authentik user {authentik_id}")


# Webhook event handlers mapping
WEBHOOK_HANDLERS = {
    "user.created": handle_user_created,
    "user.updated": handle_user_updated,
    "user.deleted": handle_user_deleted,
}


@router.post("")
async def authentik_webhook(
    request: Request,
    x_authentik_signature: str | None = Header(None, alias="X-Authentik-Signature"),
) -> dict[str, str]:
    """Handle incoming webhooks from Authentik.

    Args:
        request: FastAPI request object
        x_authentik_signature: HMAC signature from Authentik

    Returns:
        Success acknowledgment

    Raises:
        HTTPException: If signature is invalid or event handling fails
    """
    # Read raw body for signature verification
    body = await request.body()

    # Verify webhook signature
    if not verify_webhook_signature(
        body,
        x_authentik_signature or "",
        authentik_settings.webhook_secret,
    ):
        logger.warning("Invalid webhook signature received")
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid webhook signature",
        )

    # Parse payload
    try:
        payload = json.loads(body)
    except json.JSONDecodeError:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Invalid JSON payload",
        ) from None

    event_type = payload.get("event")
    if not event_type:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Missing event type",
        )

    # Get handler for event type
    handler = WEBHOOK_HANDLERS.get(event_type)
    if not handler:
        logger.info(f"Unhandled webhook event type: {event_type}")
        return {"status": "ignored", "event": event_type}

    # Process webhook with database session
    async with get_async_session() as db:
        try:
            await handler(payload, db)
        except Exception as e:
            logger.exception(f"Error handling webhook {event_type}: {e}")
            raise HTTPException(
                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                detail=f"Error processing webhook: {e}",
            ) from e

    return {"status": "processed", "event": event_type}
