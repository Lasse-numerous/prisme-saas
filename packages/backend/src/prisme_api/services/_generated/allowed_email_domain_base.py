"""Base service for AllowedEmailDomain.

⚠️ AUTO-GENERATED BY PRISM - DO NOT EDIT
Extend this class in services/allowed_email_domain.py to add custom logic.
"""

from __future__ import annotations

from collections.abc import Sequence
from typing import Any

from sqlalchemy import func, select
from sqlalchemy.orm import selectinload

from prisme_api.models.allowed_email_domain import AllowedEmailDomain
from prisme_api.schemas.allowed_email_domain import (
    AllowedEmailDomainCreate,
    AllowedEmailDomainFilter,
    AllowedEmailDomainUpdate,
)

from .base import ServiceBase


class AllowedEmailDomainServiceBase(
    ServiceBase[AllowedEmailDomain, AllowedEmailDomainCreate, AllowedEmailDomainUpdate]
):
    """Generated base service for AllowedEmailDomain.

    Extend this class in services/allowed_email_domain.py to add custom logic.
    """

    model = AllowedEmailDomain

    async def list(
        self,
        *,
        skip: int = 0,
        limit: int = 100,
        filters: AllowedEmailDomainFilter | None = None,
        sort_by: str | None = None,
        sort_order: str = "asc",
        include_deleted: bool = False,
        load_relationships: list[str] | None = None,
    ) -> Sequence[AllowedEmailDomain]:
        """List AllowedEmailDomain records with filtering and sorting.

        Args:
            skip: Number of records to skip.
            limit: Maximum number of records to return.
            filters: Filter parameters.
            sort_by: Field to sort by.
            sort_order: Sort order ('asc' or 'desc').
            include_deleted: Whether to include soft-deleted records.
            load_relationships: List of relationship names to eagerly load.

        Returns:
            List of AllowedEmailDomain records.
        """
        query = select(self.model)

        # Apply soft delete filter
        if hasattr(self.model, "deleted_at") and not include_deleted:
            query = query.where(self.model.deleted_at.is_(None))

        # Apply filters
        if filters:
            query = self._apply_filters(query, filters)

        # Eagerly load specified relationships
        if load_relationships:
            for rel_name in load_relationships:
                if hasattr(self.model, rel_name):
                    query = query.options(selectinload(getattr(self.model, rel_name)))

        # Apply sorting
        if sort_by and hasattr(self.model, sort_by):
            column = getattr(self.model, sort_by)
            if sort_order.lower() == "desc":
                column = column.desc()
            query = query.order_by(column)

        # Apply pagination
        query = query.offset(skip).limit(limit)

        result = await self.db.execute(query)
        return result.scalars().all()

    async def count_filtered(
        self,
        *,
        filters: AllowedEmailDomainFilter | None = None,
        include_deleted: bool = False,
    ) -> int:
        """Count records matching filters.

        Args:
            filters: Filter parameters.
            include_deleted: Whether to include soft-deleted records.

        Returns:
            Count of matching records.
        """
        query = select(func.count()).select_from(self.model)

        if hasattr(self.model, "deleted_at") and not include_deleted:
            query = query.where(self.model.deleted_at.is_(None))

        if filters:
            query = self._apply_filters(query, filters)

        result = await self.db.execute(query)
        return result.scalar_one()

    def _apply_filters(
        self,
        query: Any,
        filters: AllowedEmailDomainFilter,
    ) -> Any:
        """Apply filters to a query.

        Args:
            query: The SQLAlchemy query.
            filters: The filter parameters.

        Returns:
            The filtered query.
        """
        filter_data = filters.model_dump(exclude_unset=True, exclude_none=True)

        for field_name, value in filter_data.items():
            # Handle special filter suffixes
            if field_name.endswith("_ne"):
                base_field = field_name[:-3]
                if hasattr(self.model, base_field):
                    query = query.where(getattr(self.model, base_field) != value)
            elif field_name.endswith("_gt"):
                base_field = field_name[:-3]
                if hasattr(self.model, base_field):
                    query = query.where(getattr(self.model, base_field) > value)
            elif field_name.endswith("_gte"):
                base_field = field_name[:-4]
                if hasattr(self.model, base_field):
                    query = query.where(getattr(self.model, base_field) >= value)
            elif field_name.endswith("_lt"):
                base_field = field_name[:-3]
                if hasattr(self.model, base_field):
                    query = query.where(getattr(self.model, base_field) < value)
            elif field_name.endswith("_lte"):
                base_field = field_name[:-4]
                if hasattr(self.model, base_field):
                    query = query.where(getattr(self.model, base_field) <= value)
            elif field_name.endswith("_like"):
                base_field = field_name[:-5]
                if hasattr(self.model, base_field):
                    query = query.where(getattr(self.model, base_field).like(value))
            elif field_name.endswith("_ilike"):
                base_field = field_name[:-6]
                if hasattr(self.model, base_field):
                    query = query.where(getattr(self.model, base_field).ilike(value))
            elif field_name.endswith("_in"):
                base_field = field_name[:-3]
                if hasattr(self.model, base_field):
                    query = query.where(getattr(self.model, base_field).in_(value))
            elif field_name.endswith("_not_in"):
                base_field = field_name[:-7]
                if hasattr(self.model, base_field):
                    query = query.where(~getattr(self.model, base_field).in_(value))
            elif field_name.endswith("_is_null"):
                base_field = field_name[:-8]
                if hasattr(self.model, base_field):
                    if value:
                        query = query.where(getattr(self.model, base_field).is_(None))
                    else:
                        query = query.where(getattr(self.model, base_field).isnot(None))
            elif field_name.endswith("_contains"):
                base_field = field_name[:-9]
                if hasattr(self.model, base_field):
                    query = query.where(getattr(self.model, base_field).contains(value))
            elif field_name.endswith("_starts_with"):
                base_field = field_name[:-12]
                if hasattr(self.model, base_field):
                    query = query.where(getattr(self.model, base_field).startswith(value))
            elif field_name.endswith("_ends_with"):
                base_field = field_name[:-10]
                if hasattr(self.model, base_field):
                    query = query.where(getattr(self.model, base_field).endswith(value))
            elif hasattr(self.model, field_name):
                # Exact match
                query = query.where(getattr(self.model, field_name) == value)

        return query


__all__ = ["AllowedEmailDomainServiceBase"]
