/**
 * useUserFormState Hook
 *
 * A typed form state hook for User that provides:
 * - Type-safe form values
 * - Field-level validation
 * - Dirty/touched tracking
 * - Reset/submit helpers
 *
 * @example
 * ```tsx
 * const form = useUserFormState({
 *   initialValues: user ?? undefined,
 *   onSubmit: async (values) => {
 *     if (user) {
 *       await mutations.update(user.id, values);
 *     } else {
 *       await mutations.create(values);
 *     }
 *   },
 * });
 *
 * return (
 *   <form onSubmit={form.handleSubmit}>
 *     <input
 *       name="name"
 *       value={form.values.name}
 *       onChange={(e) => form.setValue('name', e.target.value)}
 *       onBlur={() => form.setTouched('name')}
 *     />
 *     {form.touched.name && form.errors.name && (
 *       <span className="error">{form.errors.name}</span>
 *     )}
 *     <button type="submit" disabled={form.isSubmitting || !form.isValid}>
 *       {form.isSubmitting ? 'Saving...' : 'Save'}
 *     </button>
 *   </form>
 * );
 * ```
 *
 * ⚠️ AUTO-GENERATED BY PRISM - DO NOT EDIT
 */

import { useState, useCallback, useMemo } from 'react';
import type {
  User,
  UserCreate,
  UserUpdate,
} from '../types/generated';

// ============================================================================
// Types
// ============================================================================

/** Form values type (same as create input) */
export type UserFormValues = UserCreate;

/** Form errors - partial record of field to error message */
export type UserFormErrors = Partial<Record<keyof UserFormValues, string>>;

/** Touched state - which fields have been touched */
export type UserFormTouched = Partial<Record<keyof UserFormValues, boolean>>;

/** Validation function type */
export type UserValidator = (
  values: Partial<UserFormValues>
) => UserFormErrors;

/** Form state hook options */
export interface UseUserFormStateOptions {
  /** Initial form values (for edit mode) */
  initialValues?: Partial<UserFormValues>;
  /** Custom validation function */
  validate?: UserValidator;
  /** Submit handler */
  onSubmit?: (values: UserFormValues) => Promise<void> | void;
  /** Whether to validate on change */
  validateOnChange?: boolean;
  /** Whether to validate on blur */
  validateOnBlur?: boolean;
}

/** Form state */
export interface UserFormState {
  /** Current form values */
  values: Partial<UserFormValues>;
  /** Validation errors */
  errors: UserFormErrors;
  /** Which fields have been touched */
  touched: UserFormTouched;
  /** Whether form is currently submitting */
  isSubmitting: boolean;
  /** Whether form has been modified from initial values */
  isDirty: boolean;
  /** Whether form has any validation errors */
  isValid: boolean;
  /** Whether form has been submitted at least once */
  isSubmitted: boolean;
}

/** Form actions */
export interface UserFormActions {
  /** Set a single field value */
  setValue: <K extends keyof UserFormValues>(
    field: K,
    value: UserFormValues[K]
  ) => void;
  /** Set multiple field values */
  setValues: (values: Partial<UserFormValues>) => void;
  /** Mark a field as touched */
  setTouched: (field: keyof UserFormValues) => void;
  /** Set a field error manually */
  setError: (field: keyof UserFormValues, message: string | undefined) => void;
  /** Validate the form and return errors */
  validate: () => UserFormErrors;
  /** Reset form to initial values */
  reset: (newInitialValues?: Partial<UserFormValues>) => void;
  /** Handle form submission */
  handleSubmit: (e?: React.FormEvent) => Promise<void>;
  /** Get props for an input field */
  getFieldProps: (field: keyof UserFormValues) => {
    name: string;
    value: unknown;
    onChange: (e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement>) => void;
    onBlur: () => void;
  };
}

/** Combined form state and actions */
export type UseUserFormStateResult = UserFormState & UserFormActions;

// ============================================================================
// Default Validation
// ============================================================================

/**
 * Default validation based on field specs.
 * Override with custom validate function if needed.
 */
function defaultValidate(values: Partial<UserFormValues>): UserFormErrors {
  const errors: UserFormErrors = {};  // email is required
  if (values.email === undefined || values.email === null || values.email === '') {
    errors.email = 'Email is required';
  }  // email max length
  if (typeof values.email === 'string' && values.email.length > 255) {
    errors.email = 'Email must be 255 characters or less';
  }  // github_id max length
  if (typeof values.githubId === 'string' && values.githubId.length > 255) {
    errors.githubId = 'Github Id must be 255 characters or less';
  }  // username max length
  if (typeof values.username === 'string' && values.username.length > 100) {
    errors.username = 'Username must be 100 characters or less';
  }
  return errors;
}

// ============================================================================
// Hook Implementation
// ============================================================================

/**
 * Hook for managing User form state.
 *
 * @param options - Form state options
 * @returns Form state and actions
 */
export function useUserFormState(
  options: UseUserFormStateOptions = {}
): UseUserFormStateResult {
  const {
    initialValues = {},
    validate = defaultValidate,
    onSubmit,
    validateOnChange = false,
    validateOnBlur = true,
  } = options;

  // State
  const [values, setValuesState] = useState<Partial<UserFormValues>>(initialValues);
  const [errors, setErrors] = useState<UserFormErrors>({});
  const [touched, setTouchedState] = useState<UserFormTouched>({});
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [isSubmitted, setIsSubmitted] = useState(false);
  const [initialValuesState, setInitialValuesState] = useState<Partial<UserFormValues>>(initialValues);

  // Computed state
  const isDirty = useMemo(() => {
    return JSON.stringify(values) !== JSON.stringify(initialValuesState);
  }, [values, initialValuesState]);

  const isValid = useMemo(() => {
    const validationErrors = validate(values);
    return Object.keys(validationErrors).length === 0;
  }, [values, validate]);

  // Actions
  const setValue = useCallback(
    <K extends keyof UserFormValues>(field: K, value: UserFormValues[K]) => {
      setValuesState((prev) => ({ ...prev, [field]: value }));
      if (validateOnChange) {
        const newValues = { ...values, [field]: value };
        const newErrors = validate(newValues);
        setErrors(newErrors);
      }
    },
    [values, validate, validateOnChange]
  );

  const setValues = useCallback(
    (newValues: Partial<UserFormValues>) => {
      setValuesState((prev) => ({ ...prev, ...newValues }));
      if (validateOnChange) {
        const merged = { ...values, ...newValues };
        const newErrors = validate(merged);
        setErrors(newErrors);
      }
    },
    [values, validate, validateOnChange]
  );

  const setTouched = useCallback(
    (field: keyof UserFormValues) => {
      setTouchedState((prev) => ({ ...prev, [field]: true }));
      if (validateOnBlur) {
        const newErrors = validate(values);
        setErrors(newErrors);
      }
    },
    [values, validate, validateOnBlur]
  );

  const setError = useCallback(
    (field: keyof UserFormValues, message: string | undefined) => {
      setErrors((prev) => {
        if (message === undefined) {
          const { [field]: _, ...rest } = prev;
          return rest;
        }
        return { ...prev, [field]: message };
      });
    },
    []
  );

  const validateForm = useCallback((): UserFormErrors => {
    const newErrors = validate(values);
    setErrors(newErrors);
    return newErrors;
  }, [values, validate]);

  const reset = useCallback(
    (newInitialValues?: Partial<UserFormValues>) => {
      const resetValues = newInitialValues ?? initialValuesState;
      setValuesState(resetValues);
      setErrors({});
      setTouchedState({});
      setIsSubmitting(false);
      setIsSubmitted(false);
      if (newInitialValues) {
        setInitialValuesState(newInitialValues);
      }
    },
    [initialValuesState]
  );

  const handleSubmit = useCallback(
    async (e?: React.FormEvent) => {
      e?.preventDefault();
      setIsSubmitted(true);

      // Mark all fields as touched
      const allTouched: UserFormTouched = {};
      for (const key of Object.keys(values) as (keyof UserFormValues)[]) {
        allTouched[key] = true;
      }
      setTouchedState(allTouched);

      // Validate
      const validationErrors = validate(values);
      setErrors(validationErrors);

      if (Object.keys(validationErrors).length > 0) {
        return;
      }

      if (onSubmit) {
        setIsSubmitting(true);
        try {
          await onSubmit(values as UserFormValues);
        } finally {
          setIsSubmitting(false);
        }
      }
    },
    [values, validate, onSubmit]
  );

  const getFieldProps = useCallback(
    (field: keyof UserFormValues) => ({
      name: String(field),
      value: values[field] ?? '',
      onChange: (e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement>) => {
        const target = e.target;
        let newValue: unknown;

        if (target.type === 'checkbox') {
          newValue = (target as HTMLInputElement).checked;
        } else if (target.type === 'number') {
          newValue = target.value === '' ? undefined : Number(target.value);
        } else {
          newValue = target.value;
        }

        setValue(field, newValue as UserFormValues[typeof field]);
      },
      onBlur: () => setTouched(field),
    }),
    [values, setValue, setTouched]
  );

  // Build state object
  const state: UserFormState = {
    values,
    errors,
    touched,
    isSubmitting,
    isDirty,
    isValid,
    isSubmitted,
  };

  // Build actions object
  const actions: UserFormActions = {
    setValue,
    setValues,
    setTouched,
    setError,
    validate: validateForm,
    reset,
    handleSubmit,
    getFieldProps,
  };

  return {
    ...state,
    ...actions,
  };
}

export default useUserFormState;
