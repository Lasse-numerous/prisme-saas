/**
 * useAPIKeyFormState Hook
 *
 * A typed form state hook for APIKey that provides:
 * - Type-safe form values
 * - Field-level validation
 * - Dirty/touched tracking
 * - Reset/submit helpers
 *
 * @example
 * ```tsx
 * const form = useAPIKeyFormState({
 *   initialValues: apikey ?? undefined,
 *   onSubmit: async (values) => {
 *     if (apikey) {
 *       await mutations.update(apikey.id, values);
 *     } else {
 *       await mutations.create(values);
 *     }
 *   },
 * });
 *
 * return (
 *   <form onSubmit={form.handleSubmit}>
 *     <input
 *       name="name"
 *       value={form.values.name}
 *       onChange={(e) => form.setValue('name', e.target.value)}
 *       onBlur={() => form.setTouched('name')}
 *     />
 *     {form.touched.name && form.errors.name && (
 *       <span className="error">{form.errors.name}</span>
 *     )}
 *     <button type="submit" disabled={form.isSubmitting || !form.isValid}>
 *       {form.isSubmitting ? 'Saving...' : 'Save'}
 *     </button>
 *   </form>
 * );
 * ```
 *
 * ⚠️ AUTO-GENERATED BY PRISM - DO NOT EDIT
 */

import { useState, useCallback, useMemo } from 'react';
import type {
  APIKey,
  APIKeyCreate,
  APIKeyUpdate,
} from '../types/generated';

// ============================================================================
// Types
// ============================================================================

/** Form values type (same as create input) */
export type APIKeyFormValues = APIKeyCreate;

/** Form errors - partial record of field to error message */
export type APIKeyFormErrors = Partial<Record<keyof APIKeyFormValues, string>>;

/** Touched state - which fields have been touched */
export type APIKeyFormTouched = Partial<Record<keyof APIKeyFormValues, boolean>>;

/** Validation function type */
export type APIKeyValidator = (
  values: Partial<APIKeyFormValues>
) => APIKeyFormErrors;

/** Form state hook options */
export interface UseAPIKeyFormStateOptions {
  /** Initial form values (for edit mode) */
  initialValues?: Partial<APIKeyFormValues>;
  /** Custom validation function */
  validate?: APIKeyValidator;
  /** Submit handler */
  onSubmit?: (values: APIKeyFormValues) => Promise<void> | void;
  /** Whether to validate on change */
  validateOnChange?: boolean;
  /** Whether to validate on blur */
  validateOnBlur?: boolean;
}

/** Form state */
export interface APIKeyFormState {
  /** Current form values */
  values: Partial<APIKeyFormValues>;
  /** Validation errors */
  errors: APIKeyFormErrors;
  /** Which fields have been touched */
  touched: APIKeyFormTouched;
  /** Whether form is currently submitting */
  isSubmitting: boolean;
  /** Whether form has been modified from initial values */
  isDirty: boolean;
  /** Whether form has any validation errors */
  isValid: boolean;
  /** Whether form has been submitted at least once */
  isSubmitted: boolean;
}

/** Form actions */
export interface APIKeyFormActions {
  /** Set a single field value */
  setValue: <K extends keyof APIKeyFormValues>(
    field: K,
    value: APIKeyFormValues[K]
  ) => void;
  /** Set multiple field values */
  setValues: (values: Partial<APIKeyFormValues>) => void;
  /** Mark a field as touched */
  setTouched: (field: keyof APIKeyFormValues) => void;
  /** Set a field error manually */
  setError: (field: keyof APIKeyFormValues, message: string | undefined) => void;
  /** Validate the form and return errors */
  validate: () => APIKeyFormErrors;
  /** Reset form to initial values */
  reset: (newInitialValues?: Partial<APIKeyFormValues>) => void;
  /** Handle form submission */
  handleSubmit: (e?: React.FormEvent) => Promise<void>;
  /** Get props for an input field */
  getFieldProps: (field: keyof APIKeyFormValues) => {
    name: string;
    value: unknown;
    onChange: (e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement>) => void;
    onBlur: () => void;
  };
}

/** Combined form state and actions */
export type UseAPIKeyFormStateResult = APIKeyFormState & APIKeyFormActions;

// ============================================================================
// Default Validation
// ============================================================================

/**
 * Default validation based on field specs.
 * Override with custom validate function if needed.
 */
function defaultValidate(values: Partial<APIKeyFormValues>): APIKeyFormErrors {
  const errors: APIKeyFormErrors = {};  // user_id is required
  if (values.userId === undefined || values.userId === null || values.userId === '') {
    errors.userId = 'User Id is required';
  }  // key_prefix is required
  if (values.keyPrefix === undefined || values.keyPrefix === null || values.keyPrefix === '') {
    errors.keyPrefix = 'Key Prefix is required';
  }  // key_prefix max length
  if (typeof values.keyPrefix === 'string' && values.keyPrefix.length > 20) {
    errors.keyPrefix = 'Key Prefix must be 20 characters or less';
  }  // name is required
  if (values.name === undefined || values.name === null || values.name === '') {
    errors.name = 'Name is required';
  }  // name max length
  if (typeof values.name === 'string' && values.name.length > 100) {
    errors.name = 'Name must be 100 characters or less';
  }
  return errors;
}

// ============================================================================
// Hook Implementation
// ============================================================================

/**
 * Hook for managing APIKey form state.
 *
 * @param options - Form state options
 * @returns Form state and actions
 */
export function useAPIKeyFormState(
  options: UseAPIKeyFormStateOptions = {}
): UseAPIKeyFormStateResult {
  const {
    initialValues = {},
    validate = defaultValidate,
    onSubmit,
    validateOnChange = false,
    validateOnBlur = true,
  } = options;

  // State
  const [values, setValuesState] = useState<Partial<APIKeyFormValues>>(initialValues);
  const [errors, setErrors] = useState<APIKeyFormErrors>({});
  const [touched, setTouchedState] = useState<APIKeyFormTouched>({});
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [isSubmitted, setIsSubmitted] = useState(false);
  const [initialValuesState, setInitialValuesState] = useState<Partial<APIKeyFormValues>>(initialValues);

  // Computed state
  const isDirty = useMemo(() => {
    return JSON.stringify(values) !== JSON.stringify(initialValuesState);
  }, [values, initialValuesState]);

  const isValid = useMemo(() => {
    const validationErrors = validate(values);
    return Object.keys(validationErrors).length === 0;
  }, [values, validate]);

  // Actions
  const setValue = useCallback(
    <K extends keyof APIKeyFormValues>(field: K, value: APIKeyFormValues[K]) => {
      setValuesState((prev) => ({ ...prev, [field]: value }));
      if (validateOnChange) {
        const newValues = { ...values, [field]: value };
        const newErrors = validate(newValues);
        setErrors(newErrors);
      }
    },
    [values, validate, validateOnChange]
  );

  const setValues = useCallback(
    (newValues: Partial<APIKeyFormValues>) => {
      setValuesState((prev) => ({ ...prev, ...newValues }));
      if (validateOnChange) {
        const merged = { ...values, ...newValues };
        const newErrors = validate(merged);
        setErrors(newErrors);
      }
    },
    [values, validate, validateOnChange]
  );

  const setTouched = useCallback(
    (field: keyof APIKeyFormValues) => {
      setTouchedState((prev) => ({ ...prev, [field]: true }));
      if (validateOnBlur) {
        const newErrors = validate(values);
        setErrors(newErrors);
      }
    },
    [values, validate, validateOnBlur]
  );

  const setError = useCallback(
    (field: keyof APIKeyFormValues, message: string | undefined) => {
      setErrors((prev) => {
        if (message === undefined) {
          const { [field]: _, ...rest } = prev;
          return rest;
        }
        return { ...prev, [field]: message };
      });
    },
    []
  );

  const validateForm = useCallback((): APIKeyFormErrors => {
    const newErrors = validate(values);
    setErrors(newErrors);
    return newErrors;
  }, [values, validate]);

  const reset = useCallback(
    (newInitialValues?: Partial<APIKeyFormValues>) => {
      const resetValues = newInitialValues ?? initialValuesState;
      setValuesState(resetValues);
      setErrors({});
      setTouchedState({});
      setIsSubmitting(false);
      setIsSubmitted(false);
      if (newInitialValues) {
        setInitialValuesState(newInitialValues);
      }
    },
    [initialValuesState]
  );

  const handleSubmit = useCallback(
    async (e?: React.FormEvent) => {
      e?.preventDefault();
      setIsSubmitted(true);

      // Mark all fields as touched
      const allTouched: APIKeyFormTouched = {};
      for (const key of Object.keys(values) as (keyof APIKeyFormValues)[]) {
        allTouched[key] = true;
      }
      setTouchedState(allTouched);

      // Validate
      const validationErrors = validate(values);
      setErrors(validationErrors);

      if (Object.keys(validationErrors).length > 0) {
        return;
      }

      if (onSubmit) {
        setIsSubmitting(true);
        try {
          await onSubmit(values as APIKeyFormValues);
        } finally {
          setIsSubmitting(false);
        }
      }
    },
    [values, validate, onSubmit]
  );

  const getFieldProps = useCallback(
    (field: keyof APIKeyFormValues) => ({
      name: String(field),
      value: values[field] ?? '',
      onChange: (e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement>) => {
        const target = e.target;
        let newValue: unknown;

        if (target.type === 'checkbox') {
          newValue = (target as HTMLInputElement).checked;
        } else if (target.type === 'number') {
          newValue = target.value === '' ? undefined : Number(target.value);
        } else {
          newValue = target.value;
        }

        setValue(field, newValue as APIKeyFormValues[typeof field]);
      },
      onBlur: () => setTouched(field),
    }),
    [values, setValue, setTouched]
  );

  // Build state object
  const state: APIKeyFormState = {
    values,
    errors,
    touched,
    isSubmitting,
    isDirty,
    isValid,
    isSubmitted,
  };

  // Build actions object
  const actions: APIKeyFormActions = {
    setValue,
    setValues,
    setTouched,
    setError,
    validate: validateForm,
    reset,
    handleSubmit,
    getFieldProps,
  };

  return {
    ...state,
    ...actions,
  };
}

export default useAPIKeyFormState;
