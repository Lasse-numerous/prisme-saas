/**
 * useSubdomainFormState Hook
 *
 * A typed form state hook for Subdomain that provides:
 * - Type-safe form values
 * - Field-level validation
 * - Dirty/touched tracking
 * - Reset/submit helpers
 *
 * @example
 * ```tsx
 * const form = useSubdomainFormState({
 *   initialValues: subdomain ?? undefined,
 *   onSubmit: async (values) => {
 *     if (subdomain) {
 *       await mutations.update(subdomain.id, values);
 *     } else {
 *       await mutations.create(values);
 *     }
 *   },
 * });
 *
 * return (
 *   <form onSubmit={form.handleSubmit}>
 *     <input
 *       name="name"
 *       value={form.values.name}
 *       onChange={(e) => form.setValue('name', e.target.value)}
 *       onBlur={() => form.setTouched('name')}
 *     />
 *     {form.touched.name && form.errors.name && (
 *       <span className="error">{form.errors.name}</span>
 *     )}
 *     <button type="submit" disabled={form.isSubmitting || !form.isValid}>
 *       {form.isSubmitting ? 'Saving...' : 'Save'}
 *     </button>
 *   </form>
 * );
 * ```
 *
 * ⚠️ AUTO-GENERATED BY PRISM - DO NOT EDIT
 */

import { useState, useCallback, useMemo } from 'react';
import type {
  Subdomain,
  SubdomainCreate,
  SubdomainUpdate,
} from '../types/generated';

// ============================================================================
// Types
// ============================================================================

/** Form values type (same as create input) */
export type SubdomainFormValues = SubdomainCreate;

/** Form errors - partial record of field to error message */
export type SubdomainFormErrors = Partial<Record<keyof SubdomainFormValues, string>>;

/** Touched state - which fields have been touched */
export type SubdomainFormTouched = Partial<Record<keyof SubdomainFormValues, boolean>>;

/** Validation function type */
export type SubdomainValidator = (
  values: Partial<SubdomainFormValues>
) => SubdomainFormErrors;

/** Form state hook options */
export interface UseSubdomainFormStateOptions {
  /** Initial form values (for edit mode) */
  initialValues?: Partial<SubdomainFormValues>;
  /** Custom validation function */
  validate?: SubdomainValidator;
  /** Submit handler */
  onSubmit?: (values: SubdomainFormValues) => Promise<void> | void;
  /** Whether to validate on change */
  validateOnChange?: boolean;
  /** Whether to validate on blur */
  validateOnBlur?: boolean;
}

/** Form state */
export interface SubdomainFormState {
  /** Current form values */
  values: Partial<SubdomainFormValues>;
  /** Validation errors */
  errors: SubdomainFormErrors;
  /** Which fields have been touched */
  touched: SubdomainFormTouched;
  /** Whether form is currently submitting */
  isSubmitting: boolean;
  /** Whether form has been modified from initial values */
  isDirty: boolean;
  /** Whether form has any validation errors */
  isValid: boolean;
  /** Whether form has been submitted at least once */
  isSubmitted: boolean;
}

/** Form actions */
export interface SubdomainFormActions {
  /** Set a single field value */
  setValue: <K extends keyof SubdomainFormValues>(
    field: K,
    value: SubdomainFormValues[K]
  ) => void;
  /** Set multiple field values */
  setValues: (values: Partial<SubdomainFormValues>) => void;
  /** Mark a field as touched */
  setTouched: (field: keyof SubdomainFormValues) => void;
  /** Set a field error manually */
  setError: (field: keyof SubdomainFormValues, message: string | undefined) => void;
  /** Validate the form and return errors */
  validate: () => SubdomainFormErrors;
  /** Reset form to initial values */
  reset: (newInitialValues?: Partial<SubdomainFormValues>) => void;
  /** Handle form submission */
  handleSubmit: (e?: React.FormEvent) => Promise<void>;
  /** Get props for an input field */
  getFieldProps: (field: keyof SubdomainFormValues) => {
    name: string;
    value: unknown;
    onChange: (e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement>) => void;
    onBlur: () => void;
  };
}

/** Combined form state and actions */
export type UseSubdomainFormStateResult = SubdomainFormState & SubdomainFormActions;

// ============================================================================
// Default Validation
// ============================================================================

/**
 * Default validation based on field specs.
 * Override with custom validate function if needed.
 */
function defaultValidate(values: Partial<SubdomainFormValues>): SubdomainFormErrors {
  const errors: SubdomainFormErrors = {};  // name is required
  if (values.name === undefined || values.name === null || values.name === '') {
    errors.name = 'Name is required';
  }  // name max length
  if (typeof values.name === 'string' && values.name.length > 63) {
    errors.name = 'Name must be 63 characters or less';
  }  // name min length
  if (typeof values.name === 'string' && values.name.length < 3) {
    errors.name = 'Name must be at least 3 characters';
  }  // ip_address max length
  if (typeof values.ipAddress === 'string' && values.ipAddress.length > 45) {
    errors.ipAddress = 'Ip Address must be 45 characters or less';
  }  // dns_record_id max length
  if (typeof values.dnsRecordId === 'string' && values.dnsRecordId.length > 50) {
    errors.dnsRecordId = 'Dns Record Id must be 50 characters or less';
  }
  return errors;
}

// ============================================================================
// Hook Implementation
// ============================================================================

/**
 * Hook for managing Subdomain form state.
 *
 * @param options - Form state options
 * @returns Form state and actions
 */
export function useSubdomainFormState(
  options: UseSubdomainFormStateOptions = {}
): UseSubdomainFormStateResult {
  const {
    initialValues = {},
    validate = defaultValidate,
    onSubmit,
    validateOnChange = false,
    validateOnBlur = true,
  } = options;

  // State
  const [values, setValuesState] = useState<Partial<SubdomainFormValues>>(initialValues);
  const [errors, setErrors] = useState<SubdomainFormErrors>({});
  const [touched, setTouchedState] = useState<SubdomainFormTouched>({});
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [isSubmitted, setIsSubmitted] = useState(false);
  const [initialValuesState, setInitialValuesState] = useState<Partial<SubdomainFormValues>>(initialValues);

  // Computed state
  const isDirty = useMemo(() => {
    return JSON.stringify(values) !== JSON.stringify(initialValuesState);
  }, [values, initialValuesState]);

  const isValid = useMemo(() => {
    const validationErrors = validate(values);
    return Object.keys(validationErrors).length === 0;
  }, [values, validate]);

  // Actions
  const setValue = useCallback(
    <K extends keyof SubdomainFormValues>(field: K, value: SubdomainFormValues[K]) => {
      setValuesState((prev) => ({ ...prev, [field]: value }));
      if (validateOnChange) {
        const newValues = { ...values, [field]: value };
        const newErrors = validate(newValues);
        setErrors(newErrors);
      }
    },
    [values, validate, validateOnChange]
  );

  const setValues = useCallback(
    (newValues: Partial<SubdomainFormValues>) => {
      setValuesState((prev) => ({ ...prev, ...newValues }));
      if (validateOnChange) {
        const merged = { ...values, ...newValues };
        const newErrors = validate(merged);
        setErrors(newErrors);
      }
    },
    [values, validate, validateOnChange]
  );

  const setTouched = useCallback(
    (field: keyof SubdomainFormValues) => {
      setTouchedState((prev) => ({ ...prev, [field]: true }));
      if (validateOnBlur) {
        const newErrors = validate(values);
        setErrors(newErrors);
      }
    },
    [values, validate, validateOnBlur]
  );

  const setError = useCallback(
    (field: keyof SubdomainFormValues, message: string | undefined) => {
      setErrors((prev) => {
        if (message === undefined) {
          const { [field]: _, ...rest } = prev;
          return rest;
        }
        return { ...prev, [field]: message };
      });
    },
    []
  );

  const validateForm = useCallback((): SubdomainFormErrors => {
    const newErrors = validate(values);
    setErrors(newErrors);
    return newErrors;
  }, [values, validate]);

  const reset = useCallback(
    (newInitialValues?: Partial<SubdomainFormValues>) => {
      const resetValues = newInitialValues ?? initialValuesState;
      setValuesState(resetValues);
      setErrors({});
      setTouchedState({});
      setIsSubmitting(false);
      setIsSubmitted(false);
      if (newInitialValues) {
        setInitialValuesState(newInitialValues);
      }
    },
    [initialValuesState]
  );

  const handleSubmit = useCallback(
    async (e?: React.FormEvent) => {
      e?.preventDefault();
      setIsSubmitted(true);

      // Mark all fields as touched
      const allTouched: SubdomainFormTouched = {};
      for (const key of Object.keys(values) as (keyof SubdomainFormValues)[]) {
        allTouched[key] = true;
      }
      setTouchedState(allTouched);

      // Validate
      const validationErrors = validate(values);
      setErrors(validationErrors);

      if (Object.keys(validationErrors).length > 0) {
        return;
      }

      if (onSubmit) {
        setIsSubmitting(true);
        try {
          await onSubmit(values as SubdomainFormValues);
        } finally {
          setIsSubmitting(false);
        }
      }
    },
    [values, validate, onSubmit]
  );

  const getFieldProps = useCallback(
    (field: keyof SubdomainFormValues) => ({
      name: String(field),
      value: values[field] ?? '',
      onChange: (e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement>) => {
        const target = e.target;
        let newValue: unknown;

        if (target.type === 'checkbox') {
          newValue = (target as HTMLInputElement).checked;
        } else if (target.type === 'number') {
          newValue = target.value === '' ? undefined : Number(target.value);
        } else {
          newValue = target.value;
        }

        setValue(field, newValue as SubdomainFormValues[typeof field]);
      },
      onBlur: () => setTouched(field),
    }),
    [values, setValue, setTouched]
  );

  // Build state object
  const state: SubdomainFormState = {
    values,
    errors,
    touched,
    isSubmitting,
    isDirty,
    isValid,
    isSubmitted,
  };

  // Build actions object
  const actions: SubdomainFormActions = {
    setValue,
    setValues,
    setTouched,
    setError,
    validate: validateForm,
    reset,
    handleSubmit,
    getFieldProps,
  };

  return {
    ...state,
    ...actions,
  };
}

export default useSubdomainFormState;
