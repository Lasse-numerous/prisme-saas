/**
 * useSubdomainTableState Hook
 *
 * A typed table state hook for Subdomain that composes:
 * - Pagination (from usePagination)
 * - Selection (from useSelection)
 * - Sorting (from useSorting)
 * - Search (from useSearch)
 * - Data fetching (from useSubdomainList)
 *
 * @example
 * ```tsx
 * const table = useSubdomainTableState({
 *   initialPageSize: 20,
 *   enableSelection: true,
 *   initialSort: { field: 'name', direction: 'asc' },
 * });
 *
 * return (
 *   <div>
 *     <SearchInput
 *       value={table.search.query}
 *       onChange={table.search.setQuery}
 *     />
 *
 *     <SubdomainTable
 *       data={table.data}
 *       loading={table.loading}
 *       sorting={table.sorting}
 *       selection={table.selection}
 *       onRowClick={table.handleRowClick}
 *     />
 *
 *     <Pagination
 *       page={table.pagination.page}
 *       totalPages={table.pagination.totalPages}
 *       onPageChange={table.pagination.setPage}
 *     />
 *   </div>
 * );
 * ```
 *
 * ⚠️ AUTO-GENERATED BY PRISM - DO NOT EDIT
 */

import { useEffect, useMemo, useCallback } from 'react';
import type { Subdomain } from '../types/generated';
import { useSubdomainList, useSubdomainMutations } from './useSubdomain';
import {
  usePagination,
  useSelection,
  useSorting,
  useSearch,
  type UsePaginationResult,
  type UseSelectionResult,
  type UseSortingResult,
  type UseSearchResult,
  type SortDirection,
} from '../prism/headless';

// ============================================================================
// Types
// ============================================================================

/** Valid sort fields for Subdomain */
export type SubdomainSortField = 'name' | 'ipAddress' | 'dnsRecordId' | 'port' | 'releasedAt' | 'cooldownUntil' | 'createdAt' | 'updatedAt';

/** Table state hook options */
export interface UseSubdomainTableStateOptions {
  /** Initial page size */
  initialPageSize?: number;
  /** Whether to enable row selection */
  enableSelection?: boolean;
  /** Initial sort configuration */
  initialSort?: {
    field: SubdomainSortField;
    direction: SortDirection;
  };
  /** Search debounce delay in ms */
  searchDebounceMs?: number;
  /** Fields to search in (for client-side search fallback) */
  searchFields?: SubdomainSortField[];
  /** Callback when row is clicked */
  onRowClick?: (item: Subdomain) => void;
}

/** Table state */
export interface SubdomainTableState {
  /** Current table data */
  data: Subdomain[];
  /** Loading state */
  loading: boolean;
  /** Error state */
  error: Error | null;
  /** Total count of items */
  totalCount: number;
  /** Whether data is empty */
  isEmpty: boolean;
  /** Pagination state and actions */
  pagination: UsePaginationResult;
  /** Selection state and actions (if enabled) */
  selection: UseSelectionResult<Subdomain>;
  /** Sorting state and actions */
  sorting: UseSortingResult<SubdomainSortField>;
  /** Search state and actions */
  search: UseSearchResult;
}

/** Table actions */
export interface SubdomainTableActions {
  /** Refetch data */
  refetch: () => void;
  /** Handle row click */
  handleRowClick: (item: Subdomain) => void;
  /** Delete a single item */
  deleteItem: (id: number) => Promise<boolean>;
  /** Delete selected items */
  deleteSelected: () => Promise<void>;
  /** Reset all table state */
  reset: () => void;
}

/** Combined table state and actions */
export type UseSubdomainTableStateResult = SubdomainTableState & SubdomainTableActions;

// ============================================================================
// Hook Implementation
// ============================================================================

/**
 * Hook for managing Subdomain table state.
 *
 * @param options - Table state options
 * @returns Table state and actions
 */
export function useSubdomainTableState(
  options: UseSubdomainTableStateOptions = {}
): UseSubdomainTableStateResult {
  const {
    initialPageSize = 20,
    enableSelection = false,
    initialSort,
    searchDebounceMs = 300,
    searchFields = ['name', 'ipAddress', 'dnsRecordId'],
    onRowClick,
  } = options;

  // Composable hooks
  const pagination = usePagination({
    initialPageSize,
  });

  const selection = useSelection<Subdomain>({
    keyExtractor: (item) => item.id,
  });

  const sorting = useSorting<SubdomainSortField>({
    initialField: initialSort?.field,
    initialDirection: initialSort?.direction,
  });

  const search = useSearch({
    debounceMs: searchDebounceMs,
  });

  // Data fetching
  const {
    data: rawData,
    loading,
    error,
    totalCount: rawTotalCount,
    refetch,
  } = useSubdomainList({
    page: pagination.page,
    pageSize: pagination.pageSize,
  });

  const { remove } = useSubdomainMutations();

  // Update pagination total when data changes
  useEffect(() => {
    pagination.setTotalItems(rawTotalCount);
  }, [rawTotalCount, pagination.setTotalItems]);

  // Apply client-side search if query exists
  // (ideally this would be server-side, but this provides a fallback)
  const data = useMemo(() => {
    if (!search.debouncedQuery || searchFields.length === 0) {
      return rawData;
    }

    const query = search.debouncedQuery.toLowerCase();
    return rawData.filter((item) =>
      searchFields.some((field) => {
        const value = item[field as keyof Subdomain];
        if (value === null || value === undefined) return false;
        return String(value).toLowerCase().includes(query);
      })
    );
  }, [rawData, search.debouncedQuery, searchFields]);

  // Computed state
  const totalCount = search.debouncedQuery ? data.length : rawTotalCount;
  const isEmpty = data.length === 0 && !loading;

  // Actions
  const handleRowClick = useCallback(
    (item: Subdomain) => {
      onRowClick?.(item);
    },
    [onRowClick]
  );

  const deleteItem = useCallback(
    async (id: number): Promise<boolean> => {
      const success = await remove(id);
      if (success) {
        refetch();
      }
      return success;
    },
    [remove, refetch]
  );

  const deleteSelected = useCallback(async () => {
    const ids = selection.selected.map((item) => item.id);
    for (const id of ids) {
      await remove(id);
    }
    selection.deselectAll();
    refetch();
  }, [selection, remove, refetch]);

  const reset = useCallback(() => {
    pagination.reset();
    selection.reset();
    sorting.reset();
    search.reset();
  }, [pagination, selection, sorting, search]);

  // Build state object
  const state: SubdomainTableState = {
    data,
    loading,
    error,
    totalCount,
    isEmpty,
    pagination,
    selection,
    sorting,
    search,
  };

  // Build actions object
  const actions: SubdomainTableActions = {
    refetch,
    handleRowClick,
    deleteItem,
    deleteSelected,
    reset,
  };

  return {
    ...state,
    ...actions,
  };
}

export default useSubdomainTableState;
