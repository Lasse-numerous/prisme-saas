--- generated+++ user@@ -1,14 +1,17 @@ """Authentik authentication routes.

-AUTO-GENERATED BY PRISM - DO NOT EDIT
+⚠️ AUTO-GENERATED BY PRISM - DO NOT EDIT
 Endpoints for OIDC authentication flow with Authentik.
 """

 from __future__ import annotations

+import json
+import os
 import secrets
 from typing import Annotated

+import redis.asyncio as redis
 from fastapi import APIRouter, Cookie, Depends, HTTPException, Response, status
 from fastapi.responses import RedirectResponse
 from sqlalchemy import select
@@ -23,8 +26,35 @@
 router = APIRouter(prefix="/auth", tags=["authentication"])

-# In-memory state store (use Redis in production for distributed systems)
-_state_store: dict[str, dict] = {}
+# Redis client for distributed state storage
+REDIS_URL = os.getenv("REDIS_URL", "redis://localhost:6379")
+_redis_client: redis.Redis | None = None
+STATE_TTL = 600  # State expires after 10 minutes
+
+
+async def get_redis() -> redis.Redis:
+    """Get or create Redis client."""
+    global _redis_client
+    if _redis_client is None:
+        _redis_client = redis.from_url(REDIS_URL, decode_responses=True)
+    return _redis_client
+
+
+async def store_state(state: str, data: dict) -> None:
+    """Store state in Redis with TTL."""
+    client = await get_redis()
+    await client.setex(f"oauth_state:{state}", STATE_TTL, json.dumps(data))
+
+
+async def get_and_delete_state(state: str) -> dict | None:
+    """Get and delete state from Redis."""
+    client = await get_redis()
+    key = f"oauth_state:{state}"
+    data = await client.get(key)
+    if data:
+        await client.delete(key)
+        return json.loads(data)
+    return None


 @router.get("/login")
@@ -40,8 +70,8 @@     state = secrets.token_urlsafe(32)
     nonce = secrets.token_urlsafe(32)

-    # Store state and nonce for verification on callback
-    _state_store[state] = {"nonce": nonce}
+    # Store state and nonce in Redis for verification on callback
+    await store_state(state, {"nonce": nonce})

     authorization_url = oidc_client.get_authorization_url(
         state=state,
@@ -73,8 +103,8 @@     Raises:
         HTTPException: If state is invalid or token exchange fails
     """
-    # Verify state
-    stored = _state_store.pop(state, None)
+    # Verify state from Redis
+    stored = await get_and_delete_state(state)
     if not stored:
         raise HTTPException(
             status_code=status.HTTP_400_BAD_REQUEST,
@@ -96,10 +126,22 @@
         # Get or create local user
         authentik_id = claims.get("sub")
-        result = await db.execute(
-            select(User).where(User.authentik_id == authentik_id)
-        )
+        result = await db.execute(select(User).where(User.authentik_id == authentik_id))
         user = result.scalar_one_or_none()
+
+        # Validate email domain against whitelist for new users
+        if not user:
+            from prisme_api.services.allowed_email_domain import AllowedEmailDomainService
+
+            email_domain_service = AllowedEmailDomainService(db)
+            email = claims.get("email", f"{claims.get('preferred_username', 'user')}@local")
+
+            if not await email_domain_service.is_domain_allowed(email):
+                domain = email.split("@")[1] if "@" in email else "unknown"
+                raise HTTPException(
+                    status_code=status.HTTP_403_FORBIDDEN,
+                    detail=f"Email domain '{domain}' is not allowed for signup. Contact admin for access.",
+                )

         if not user:
             # Create new user from claims
@@ -136,10 +178,13 @@         return response

     except OIDCError as e:
+        import logging
+
+        logging.error(f"OIDC authentication error: {e}")
         raise HTTPException(
             status_code=status.HTTP_400_BAD_REQUEST,
             detail=f"Authentication failed: {e}",
-        )
+        ) from e


 @router.get("/logout")
