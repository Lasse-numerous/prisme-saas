--- generated+++ user@@ -1,7 +1,6 @@-"""Authentication routes — cookie-based JWT sessions.
-
-⚠️ AUTO-GENERATED BY PRISM (GENERATE_ONCE)
-Signup, login, email verification, password reset, MFA/TOTP, OAuth.
+"""Authentication routes — self-contained (no Authentik).
+
+Signup, login, email verification, password reset, MFA/TOTP, GitHub OAuth.
 """

 from __future__ import annotations
@@ -16,47 +15,87 @@ import httpx
 from fastapi import APIRouter, Cookie, Depends, HTTPException, Query, Response, status
 from fastapi.responses import RedirectResponse
+from pydantic import BaseModel, EmailStr
 from sqlalchemy import select
 from sqlalchemy.ext.asyncio import AsyncSession

-from prisme_api.auth.password_service import (
+from prisme_api.auth.config import auth_settings
+from prisme_api.auth.dependencies import CurrentActiveUser, create_session_jwt
+from prisme_api.auth.utils import (
     generate_token,
+    generate_totp_secret,
+    get_totp_uri,
     hash_password,
     validate_password_strength,
     verify_password,
+    verify_totp,
 )
-from prisme_api.auth.token_service import create_session_jwt
-from prisme_api.auth.config import auth_settings
 from prisme_api.database import get_db
-from prisme_api.middleware.auth import CurrentActiveUser
 from prisme_api.models.user import User
-from prisme_api.schemas.auth import (
-    LoginRequest,
-    LoginResponse,
-    UserResponse,
-    LoginMFARequest,
-    MFADisableRequest,
-    MFASetupResponse,
-    MFAVerifySetupRequest,
-    ResendVerificationRequest,
-    VerifyEmailRequest,
-    ForgotPasswordRequest,
-    ResetPasswordRequest,
-)
+from prisme_api.schemas.auth import UserResponse
 from prisme_api.services.email_service import (
-    send_verification_email,
     send_password_changed_notification,
     send_password_reset_email,
+    send_verification_email,
 )
-from prisme_api.auth.totp_service import (
-    generate_totp_secret,
-    get_totp_uri,
-    verify_totp,
-)

 logger = logging.getLogger(__name__)

 router = APIRouter(prefix="/auth", tags=["authentication"])
+
+
+# ── Request/Response schemas ────────────────────────────────────
+
+
+class SignupRequest(BaseModel):
+    email: EmailStr
+    username: str
+    password: str
+
+
+class LoginRequest(BaseModel):
+    email: EmailStr
+    password: str
+
+
+class LoginMFARequest(BaseModel):
+    email: EmailStr
+    code: str
+
+
+class VerifyEmailRequest(BaseModel):
+    token: str
+
+
+class ResendVerificationRequest(BaseModel):
+    email: EmailStr
+
+
+class ForgotPasswordRequest(BaseModel):
+    email: EmailStr
+
+
+class ResetPasswordRequest(BaseModel):
+    token: str
+    password: str
+
+
+class MFAVerifySetupRequest(BaseModel):
+    code: str
+
+
+class MFADisableRequest(BaseModel):
+    password: str
+
+
+class LoginResponse(BaseModel):
+    requires_mfa: bool = False
+    user: dict | None = None
+
+
+class MFASetupResponse(BaseModel):
+    totp_uri: str
+    secret: str


 # ── Helpers ─────────────────────────────────────────────────────
@@ -99,8 +138,10 @@ def _record_failed_login(user: User) -> None:
     """Increment failed attempts and lock if threshold reached."""
     user.failed_login_attempts = (user.failed_login_attempts or 0) + 1
-    if user.failed_login_attempts >= 5:
-        user.locked_until = datetime.now(UTC) + timedelta(minutes=15)
+    if user.failed_login_attempts >= auth_settings.max_failed_login_attempts:
+        user.locked_until = datetime.now(UTC) + timedelta(
+            minutes=auth_settings.lockout_duration_minutes
+        )


 def _reset_failed_logins(user: User) -> None:
@@ -108,6 +149,22 @@     user.locked_until = None


+async def _validate_email_domain(db: AsyncSession, email: str) -> None:
+    """Check email domain against whitelist."""
+    try:
+        from prisme_api.services.allowed_email_domain import AllowedEmailDomainService
+
+        domain_service = AllowedEmailDomainService(db)
+        if not await domain_service.is_domain_allowed(email):
+            domain = email.split("@")[1] if "@" in email else "unknown"
+            raise HTTPException(
+                status_code=status.HTTP_403_FORBIDDEN,
+                detail=f"Email domain '{domain}' is not allowed for signup.",
+            )
+    except ImportError:
+        pass
+
+
 # ── Signup ──────────────────────────────────────────────────────


@@ -117,21 +174,23 @@     db: Annotated[AsyncSession, Depends(get_db)],
 ) -> dict[str, str]:
     """Create a new user account and send verification email."""
-    from prisme_api.schemas.auth import SignupRequest
-
+    # Validate password
     pw_error = validate_password_strength(body.password)
     if pw_error:
         raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=pw_error)

-    result = await db.execute(
-        select(User).where(User.email == body.email)
-    )
+    # Check if email already exists
+    result = await db.execute(select(User).where(User.email == body.email))
     if result.scalar_one_or_none():
         raise HTTPException(
             status_code=status.HTTP_409_CONFLICT,
             detail="An account with this email already exists.",
         )

+    # Validate email domain
+    await _validate_email_domain(db, body.email)
+
+    # Create user
     token = generate_token()
     user = User(
         email=body.email,
@@ -140,14 +199,16 @@         email_verified=False,
         email_verification_token=token,
         email_verification_token_expires_at=datetime.now(UTC)
-        + timedelta(hours=24),
+        + timedelta(hours=auth_settings.email_verification_token_hours),
         roles=["user"],
         is_active=True,
     )
     db.add(user)
     await db.commit()

+    # Send verification email
     send_verification_email(body.email, token)
+
     return {"message": "Account created. Please check your email to verify your address."}


@@ -161,9 +222,7 @@     db: Annotated[AsyncSession, Depends(get_db)],
 ) -> dict:
     """Verify email address and auto-login."""
-    result = await db.execute(
-        select(User).where(User.email_verification_token == body.token)
-    )
+    result = await db.execute(select(User).where(User.email_verification_token == body.token))
     user = result.scalar_one_or_none()

     if not user:
@@ -187,6 +246,7 @@     await db.commit()
     await db.refresh(user)

+    # Auto-login
     token = create_session_jwt(user)
     _set_session_cookie(response, token)

@@ -199,16 +259,14 @@     db: Annotated[AsyncSession, Depends(get_db)],
 ) -> dict[str, str]:
     """Resend verification email. Always returns 200 to prevent email enumeration."""
-    result = await db.execute(
-        select(User).where(User.email == body.email)
-    )
+    result = await db.execute(select(User).where(User.email == body.email))
     user = result.scalar_one_or_none()

     if user and not user.email_verified:
         token = generate_token()
         user.email_verification_token = token
         user.email_verification_token_expires_at = datetime.now(UTC) + timedelta(
-            hours=24
+            hours=auth_settings.email_verification_token_hours
         )
         await db.commit()
         send_verification_email(body.email, token)
@@ -225,10 +283,8 @@     response: Response,
     db: Annotated[AsyncSession, Depends(get_db)],
 ) -> LoginResponse:
-    """Login with email and password."""
-    result = await db.execute(
-        select(User).where(User.email == body.email)
-    )
+    """Login with email and password. Returns requires_mfa if MFA is enabled."""
+    result = await db.execute(select(User).where(User.email == body.email))
     user = result.scalar_one_or_none()

     if not user or not user.password_hash:
@@ -284,9 +340,7 @@     db: Annotated[AsyncSession, Depends(get_db)],
 ) -> LoginResponse:
     """Complete MFA login with TOTP code."""
-    result = await db.execute(
-        select(User).where(User.email == body.email)
-    )
+    result = await db.execute(select(User).where(User.email == body.email))
     user = result.scalar_one_or_none()

     if not user or not user.mfa_secret:
@@ -325,16 +379,14 @@     db: Annotated[AsyncSession, Depends(get_db)],
 ) -> dict[str, str]:
     """Send password reset email. Always returns 200 to prevent email enumeration."""
-    result = await db.execute(
-        select(User).where(User.email == body.email)
-    )
+    result = await db.execute(select(User).where(User.email == body.email))
     user = result.scalar_one_or_none()

     if user:
         token = generate_token()
         user.password_reset_token = token
         user.password_reset_token_expires_at = datetime.now(UTC) + timedelta(
-            hours=1
+            hours=auth_settings.password_reset_token_hours
         )
         await db.commit()
         send_password_reset_email(body.email, token)
@@ -353,9 +405,7 @@     if pw_error:
         raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=pw_error)

-    result = await db.execute(
-        select(User).where(User.password_reset_token == body.token)
-    )
+    result = await db.execute(select(User).where(User.password_reset_token == body.token))
     user = result.scalar_one_or_none()

     if not user:
@@ -364,9 +414,8 @@             detail="Invalid or expired reset token.",
         )

-    if (
-        user.password_reset_token_expires_at
-        and user.password_reset_token_expires_at < datetime.now(UTC)
+    if user.password_reset_token_expires_at and user.password_reset_token_expires_at < datetime.now(
+        UTC
     ):
         raise HTTPException(
             status_code=status.HTTP_400_BAD_REQUEST,
@@ -382,6 +431,7 @@
     send_password_changed_notification(user.email)

+    # Auto-login
     token = create_session_jwt(user)
     _set_session_cookie(response, token)

@@ -398,6 +448,7 @@ ) -> MFASetupResponse:
     """Generate TOTP secret and URI for QR code. Requires authentication."""
     secret = generate_totp_secret()
+    # Store pending secret (not yet enabled)
     current_user.mfa_secret = secret
     await db.commit()

@@ -457,6 +508,7 @@ GITHUB_USER_API = "https://api.github.com/user"
 GITHUB_EMAILS_API = "https://api.github.com/user/emails"

+# In-memory state store (acceptable for single-instance; use Redis if scaling)
 _oauth_states: dict[str, float] = {}


@@ -510,6 +562,7 @@             url="/auth/callback?error=missing_params", status_code=status.HTTP_302_FOUND
         )

+    # Validate CSRF state
     if state not in _oauth_states:
         return RedirectResponse(
             url="/auth/callback?error=invalid_state", status_code=status.HTTP_302_FOUND
@@ -517,6 +570,7 @@     _oauth_states.pop(state, None)

     async with httpx.AsyncClient() as client:
+        # Exchange code for access token
         token_resp = await client.post(
             GITHUB_TOKEN_URL,
             data={
@@ -544,6 +598,7 @@
         auth_headers = {"Authorization": f"Bearer {access_token}"}

+        # Get user profile
         user_resp = await client.get(GITHUB_USER_API, headers=auth_headers)
         if user_resp.status_code != 200:
             return RedirectResponse(
@@ -552,6 +607,7 @@             )
         gh_user = user_resp.json()

+        # Get primary verified email
         email = gh_user.get("email")
         if not email:
             emails_resp = await client.get(GITHUB_EMAILS_API, headers=auth_headers)
@@ -566,9 +622,11 @@                 url="/auth/callback?error=no_email", status_code=status.HTTP_302_FOUND
             )

+    # Find or create user
     username = gh_user.get("login", email.split("@")[0])
     github_id = str(gh_user.get("id", ""))

+    # Try finding by github_id first
     result = await db.execute(select(User).where(User.github_id == github_id))
     user = result.scalar_one_or_none()

@@ -577,15 +635,19 @@         user = result.scalar_one_or_none()

     if user:
+        # Link github_id if not set
         if not user.github_id:
             user.github_id = github_id
             await db.commit()
     else:
+        # Validate email domain
+        await _validate_email_domain(db, email)
+
         user = User(
             email=email,
             username=username,
             github_id=github_id,
-            email_verified=True,
+            email_verified=True,  # GitHub emails are verified
             is_active=True,
             roles=["user"],
         )
@@ -593,9 +655,9 @@         await db.commit()
         await db.refresh(user)

-    jwt_token = create_session_jwt(user)
+    token = create_session_jwt(user)
     redirect = RedirectResponse(url="/auth/callback", status_code=status.HTTP_302_FOUND)
-    _set_session_cookie(redirect, jwt_token)
+    _set_session_cookie(redirect, token)
     return redirect


@@ -625,8 +687,6 @@     session_token: str | None = Cookie(None, alias=auth_settings.session_cookie_name),
 ) -> RedirectResponse:
     """Logout via GET: clear cookie and redirect to login."""
-    from fastapi.responses import RedirectResponse
-
     redirect = RedirectResponse(url="/login", status_code=status.HTTP_302_FOUND)
     redirect.delete_cookie(
         key=auth_settings.session_cookie_name,
